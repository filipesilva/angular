{"version":3,"sources":["webpack:///./node_modules/@angular/material/esm5/card.es5.js.pre-build-optimizer.js","webpack:///./node_modules/@angular/material/esm5/tabs.es5.js.pre-build-optimizer.js","webpack:///./src/app/custom-elements/code/code-tabs.component.ts.pre-build-optimizer.js","webpack:///./src/app/custom-elements/code/code-tabs.component.ts","webpack:///./src/app/custom-elements/code/code-tabs.module.ts","webpack:///./src/app/custom-elements/code/code-tabs.module.ts.pre-build-optimizer.js","webpack:///./src/app/custom-elements/code/code-tabs.module.ngfactory.ts"],"names":["_c12","_c13","_c14","card_es5_MatCard","MatCard","ngComponentDef","definition","type","selectors","factory","t","hostBindings","rf","ctx","elIndex","instructions_element","exportAs","ngContentSelectors","consts","vars","template","projection","styles","encapsulation","changeDetection","card_es5_MatCardModule","MatCardModule","ngModuleDef","ngInjectorDef","defs","imports","core_es5","tabs_es5_c0","MatTab_ng_template_0_Template","tabs_es5_c1","tabs_es5_c2","tabs_es5_c3","tabs_es5_c4","tabs_es5_c5","MatTabBody_ng_template_2_Template","tabs_es5_c6","tabs_es5_c7","tabs_es5_c8","tabs_es5_c9","tabs_es5_c10","tabs_es5_c11","tabs_es5_c12","tabs_es5_c13","tabs_es5_c14","tabs_es5_c15","tabs_es5_c16","tabs_es5_c17","tabs_es5_c18","tabs_es5_c19","tabs_es5_c20","tabs_es5_c21","_c22","_c23","_c24","_c25","_c26","_c27","_c28","_c29","_c30","_c31","_c32","_c33","MatTabGroup_div_2_ng_template_2_ng_template_0_Template","MatTabGroup_div_2_ng_template_2_Template","container","tab_r348","next_context","$implicit","instructions_select","property","templateLabel","MatTabGroup_div_2_ng_template_3_Template","instructions_text","property_interpolation","textLabel","_c34","MatTabGroup_div_2_Template","_r356","get_current_view","styling_instructions","listener","$event","state","i_r349","index","ctx_r355","_r344","storage","_handleClick","ctx_r345","selectedIndex","_getTabLabelId","_getTabIndex","_tabs","length","_getTabContentId","ariaLabel","ariaLabelledby","disabled","disableRipple","_c35","_c36","MatTabGroup_mat_tab_body_5_Template","_r360","_removeTabBodyWrapperHeight","_setTabBodyWrapperHeight","tab_r357","i_r358","ctx_r347","content","position","origin","_MAT_INK_BAR_POSITIONER","injection_token","providedIn","element","left","offsetLeft","width","offsetWidth","tabs_es5_MatInkBar","MatInkBar","_elementRef","_ngZone","_inkBarPositioner","this","prototype","alignToElement","_this","show","requestAnimationFrame","runOutsideAngular","_setStyles","nativeElement","style","visibility","hide","positions","inkBar","ngDirectiveDef","instructions_di","element_ref","ng_zone","tabs_es5_MatTabContent","MatTabContent","template_ref","tabs_es5_MatTabLabel","_super","MatTabLabel","apply","arguments","Object","tslib_es6","ɵMatTabLabel_BaseFactory","features","inherit_definition_feature","render3_di","portal_es5","MatTabBase","tabs_es5_MatTab","MatTab","_viewContainerRef","call","_contentPortal","_stateChanges","Subject","isActive","defineProperty","get","enumerable","configurable","ngOnChanges","changes","hasOwnProperty","next","ngOnDestroy","complete","ngOnInit","_explicitContent","_implicitContent","view_container_ref","contentQueries","dirIndex","_t","query","first","viewQuery","inputs","ng_onchanges_feature","matTabsAnimations","translateTab","animations","transform","minHeight","tabs_es5_MatTabBodyPortal","MatTabBodyPortal","componentFactoryResolver","viewContainerRef","_host","_centeringSub","Subscription","EMPTY","_leavingSub","_beforeCentering","pipe","startWith","_isCenterPosition","_position","subscribe","isCentering","hasAttached","attach","_content","_afterLeavingCenter","detach","unsubscribe","component_factory_resolver","forward_ref","tabs_es5_MatTabBody","MatTabBody","_dir","changeDetectorRef","_dirChangeSubscription","_onCentering","event_emitter","_onCentered","change","dir","_computePositionAnimationState","markForCheck","set","_positionIndex","_computePositionFromOrigin","_onTranslateTabStarted","e","toState","emit","clientHeight","_onTranslateTabComplete","fromState","_getLayoutDirection","value","bidi_es5","change_detector_ref","_portalHost","outputs","directives","data","animation","MatTabLabelWrapperBase","tabs_es5_MatTabLabelWrapper","MatTabLabelWrapper","elementRef","focus","getOffsetLeft","getOffsetWidth","alloc_host_vars","MatTabHeaderBase","tabs_es5_MatTabHeader","MatTabHeader","_changeDetectorRef","_viewportRuler","_scrollDistance","_selectedIndexChanged","_destroyed","_showPaginationControls","_disableScrollAfter","_disableScrollBefore","_selectedIndex","selectFocusedIndex","indexFocused","coercion_es5","_keyManager","updateActiveItemIndex","ngAfterContentChecked","_tabLabelCount","_labelWrappers","_updatePagination","_scrollToLabel","_checkScrollingControls","_alignInkBarToSelectedTab","_scrollDistanceChanged","_updateTabScrollPosition","_handleKeydown","event","keyCode","keycodes_es5","setFirstItemActive","preventDefault","setLastItemActive","focusIndex","onKeydown","ngAfterContentInit","dirChange","of","resize","realign","a11y_es5","withHorizontalOrientation","withWrap","updateActiveItem","merge","takeUntil","newFocusIndex","_setTabFocus","_onContentChanges","zoneCallback","run","_checkPaginationEnabled","_isValidIndex","setActiveItem","tab","toArray","tabIndex","containerEl","_tabListContainer","scrollLeft","scrollWidth","scrollDistance","translateX","_tabList","v","Math","max","min","_getMaxScrollDistance","_scrollHeader","scrollDir","labelIndex","selectedLabel","labelBeforePos","labelAfterPos","viewLength","beforeVisiblePos","afterVisiblePos","isEnabled","selectedLabelWrapper","_inkBar","scrolling_es5","observers_es5","nextId","MatTabChangeEvent","MatTabGroupBase","tabs_es5_MatTabGroup","MatTabGroup","_indexToSelect","_tabBodyWrapperHeight","_tabsSubscription","_tabLabelSubscription","_dynamicHeight","headerPosition","selectedIndexChange","focusChange","animationDone","selectedTabChange","_groupId","_backgroundColor","classList","remove","backgroundColor","add","indexToSelect","_clampTabIndex","isFirstRun_1","_createChangeEvent","Promise","resolve","then","forEach","_subscribeToTabLabels","tabs","i","realignInkBar","_tabHeader","_focusChanged","map","tabHeight","wrapper","_tabBodyWrapper","height","offsetHeight","tabHeader","idx","dynamicHeight","color","common","tabs_es5_MatTabsModule","MatTabsModule","code_tabs_component_c0","code_tabs_component_c1","code_tabs_component_c2","code_tabs_component_c3","code_tabs_component_c4","code_tabs_component_c5","code_tabs_component_c6","code_tabs_component_c7","CodeTabsComponent_mat_tab_5_ng_template_1_Template","tab_r90","class","header","CodeTabsComponent_mat_tab_5_Template","language","linenums","path","region","code_tabs_component_c8","code_tabs_component_CodeTabsComponent","CodeTabsComponent","codeExamples","querySelectorAll","push","getTabInfo","ngAfterViewInit","codeComponents","codeComponent","code","tabContent","getAttribute","innerHTML","code_component","code_tabs_module_CodeTabsModule","CodeTabsModule","customElementComponent","code_module","__webpack_require__","d","__webpack_exports__","CodeTabsModuleNgFactory","ng_module_ref"],"mappings":"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","file":"code-code-tabs-module-ngfactory.eaff37853af548fd3b4b.js","sourcesContent":["import * as ɵngcc0 from '@angular/core';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Component, ViewEncapsulation, ChangeDetectionStrategy, Directive, Input, NgModule } from '@angular/core';\nimport { MatCommonModule } from '@angular/material/core';\nconst _c0 = [1, \"mat-card-content\"];\nconst _c1 = [1, \"mat-card-title\"];\nconst _c2 = [1, \"mat-card-subtitle\"];\nconst _c3 = [1, \"mat-card-actions\"];\nconst _c4 = [\"mat-card-actions-align-end\"];\nconst _c5 = [1, \"mat-card-footer\"];\nconst _c6 = [1, \"mat-card-image\"];\nconst _c7 = [1, \"mat-card-sm-image\"];\nconst _c8 = [1, \"mat-card-md-image\"];\nconst _c9 = [1, \"mat-card-lg-image\"];\nconst _c10 = [1, \"mat-card-xl-image\"];\nconst _c11 = [1, \"mat-card-avatar\"];\nconst _c12 = [1, \"mat-card\"];\nconst _c13 = [[[\"mat-card-footer\"]]];\nconst _c14 = [\"mat-card-footer\"];\nconst _c15 = [1, \"mat-card-header\"];\nconst _c16 = [1, \"mat-card-header-text\"];\nconst _c17 = [[[\"\", \"mat-card-avatar\", \"\"], [\"\", \"matCardAvatar\", \"\"]], [[\"mat-card-title\"], [\"mat-card-subtitle\"], [\"\", \"mat-card-title\", \"\"], [\"\", \"mat-card-subtitle\", \"\"], [\"\", \"matCardTitle\", \"\"], [\"\", \"matCardSubtitle\", \"\"]]];\nconst _c18 = [\"[mat-card-avatar], [matCardAvatar]\", \"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"];\nconst _c19 = [1, \"mat-card-title-group\"];\nconst _c20 = [[[\"mat-card-title\"], [\"mat-card-subtitle\"], [\"\", \"mat-card-title\", \"\"], [\"\", \"mat-card-subtitle\", \"\"], [\"\", \"matCardTitle\", \"\"], [\"\", \"matCardSubtitle\", \"\"]], [[\"img\"]]];\nconst _c21 = [\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\", \"img\"];\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Content of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardContent = /** @class */ (function () {\n    function MatCardContent() {\n    }\nMatCardContent.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardContent, selectors: [[\"mat-card-content\"]], factory: function MatCardContent_Factory(t) { return new (t || MatCardContent)(); }, hostBindings: function MatCardContent_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c0);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardContent, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'mat-card-content',\r\n                host: { 'class': 'mat-card-content' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardContent;\n}());\n/**\n * Title of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardTitle = /** @class */ (function () {\n    function MatCardTitle() {\n    }\nMatCardTitle.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardTitle, selectors: [[\"mat-card-title\"], [\"\", \"mat-card-title\", \"\"], [\"\", \"matCardTitle\", \"\"]], factory: function MatCardTitle_Factory(t) { return new (t || MatCardTitle)(); }, hostBindings: function MatCardTitle_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c1);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardTitle, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: \"mat-card-title, [mat-card-title], [matCardTitle]\",\r\n                host: {\r\n                    'class': 'mat-card-title'\r\n                }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardTitle;\n}());\n/**\n * Sub-title of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardSubtitle = /** @class */ (function () {\n    function MatCardSubtitle() {\n    }\nMatCardSubtitle.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardSubtitle, selectors: [[\"mat-card-subtitle\"], [\"\", \"mat-card-subtitle\", \"\"], [\"\", \"matCardSubtitle\", \"\"]], factory: function MatCardSubtitle_Factory(t) { return new (t || MatCardSubtitle)(); }, hostBindings: function MatCardSubtitle_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c2);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardSubtitle, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: \"mat-card-subtitle, [mat-card-subtitle], [matCardSubtitle]\",\r\n                host: {\r\n                    'class': 'mat-card-subtitle'\r\n                }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardSubtitle;\n}());\n/**\n * Action section of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardActions = /** @class */ (function () {\n    function MatCardActions() {\n        /**\n         * Position of the actions inside the card.\n         */\n        this.align = 'start';\n    }\n    MatCardActions.propDecorators = {\n        align: [{ type: Input }]\n    };\nMatCardActions.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardActions, selectors: [[\"mat-card-actions\"]], factory: function MatCardActions_Factory(t) { return new (t || MatCardActions)(); }, hostBindings: function MatCardActions_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c3);\r\n        ɵngcc0.ɵelementHostStyling(_c4);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵelementHostClassProp(0, (ctx.align === \"end\"));\r\n        ɵngcc0.ɵelementHostStylingApply();\r\n    } }, inputs: { align: \"align\" }, exportAs: [\"matCardActions\"] });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardActions, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'mat-card-actions',\r\n                exportAs: 'matCardActions',\r\n                host: {\r\n                    'class': 'mat-card-actions',\r\n                    '[class.mat-card-actions-align-end]': 'align === \"end\"'\r\n                }\r\n            }]\r\n    }], function () { return []; }, { align: [{\r\n            type: Input\r\n        }] });\n    return MatCardActions;\n}());\n/**\n * Footer of a card, needed as it's used as a selector in the API.\n * \\@docs-private\n */\nvar MatCardFooter = /** @class */ (function () {\n    function MatCardFooter() {\n    }\nMatCardFooter.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardFooter, selectors: [[\"mat-card-footer\"]], factory: function MatCardFooter_Factory(t) { return new (t || MatCardFooter)(); }, hostBindings: function MatCardFooter_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c5);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardFooter, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'mat-card-footer',\r\n                host: { 'class': 'mat-card-footer' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardFooter;\n}());\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardImage = /** @class */ (function () {\n    function MatCardImage() {\n    }\nMatCardImage.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardImage, selectors: [[\"\", \"mat-card-image\", \"\"], [\"\", \"matCardImage\", \"\"]], factory: function MatCardImage_Factory(t) { return new (t || MatCardImage)(); }, hostBindings: function MatCardImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c6);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-image], [matCardImage]',\r\n                host: { 'class': 'mat-card-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardImage;\n}());\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardSmImage = /** @class */ (function () {\n    function MatCardSmImage() {\n    }\nMatCardSmImage.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardSmImage, selectors: [[\"\", \"mat-card-sm-image\", \"\"], [\"\", \"matCardImageSmall\", \"\"]], factory: function MatCardSmImage_Factory(t) { return new (t || MatCardSmImage)(); }, hostBindings: function MatCardSmImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c7);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardSmImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-sm-image], [matCardImageSmall]',\r\n                host: { 'class': 'mat-card-sm-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardSmImage;\n}());\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardMdImage = /** @class */ (function () {\n    function MatCardMdImage() {\n    }\nMatCardMdImage.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardMdImage, selectors: [[\"\", \"mat-card-md-image\", \"\"], [\"\", \"matCardImageMedium\", \"\"]], factory: function MatCardMdImage_Factory(t) { return new (t || MatCardMdImage)(); }, hostBindings: function MatCardMdImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c8);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardMdImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-md-image], [matCardImageMedium]',\r\n                host: { 'class': 'mat-card-md-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardMdImage;\n}());\n/**\n * Image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardLgImage = /** @class */ (function () {\n    function MatCardLgImage() {\n    }\nMatCardLgImage.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardLgImage, selectors: [[\"\", \"mat-card-lg-image\", \"\"], [\"\", \"matCardImageLarge\", \"\"]], factory: function MatCardLgImage_Factory(t) { return new (t || MatCardLgImage)(); }, hostBindings: function MatCardLgImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c9);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardLgImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-lg-image], [matCardImageLarge]',\r\n                host: { 'class': 'mat-card-lg-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardLgImage;\n}());\n/**\n * Large image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardXlImage = /** @class */ (function () {\n    function MatCardXlImage() {\n    }\nMatCardXlImage.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardXlImage, selectors: [[\"\", \"mat-card-xl-image\", \"\"], [\"\", \"matCardImageXLarge\", \"\"]], factory: function MatCardXlImage_Factory(t) { return new (t || MatCardXlImage)(); }, hostBindings: function MatCardXlImage_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c10);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardXlImage, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-xl-image], [matCardImageXLarge]',\r\n                host: { 'class': 'mat-card-xl-image' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardXlImage;\n}());\n/**\n * Avatar image used in a card, needed to add the mat- CSS styling.\n * \\@docs-private\n */\nvar MatCardAvatar = /** @class */ (function () {\n    function MatCardAvatar() {\n    }\nMatCardAvatar.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatCardAvatar, selectors: [[\"\", \"mat-card-avatar\", \"\"], [\"\", \"matCardAvatar\", \"\"]], factory: function MatCardAvatar_Factory(t) { return new (t || MatCardAvatar)(); }, hostBindings: function MatCardAvatar_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c11);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardAvatar, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-card-avatar], [matCardAvatar]',\r\n                host: { 'class': 'mat-card-avatar' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardAvatar;\n}());\n/**\n * A basic content container component that adds the styles of a Material design card.\n *\n * While this component can be used alone, it also provides a number\n * of preset styles for common card sections, including:\n * - mat-card-title\n * - mat-card-subtitle\n * - mat-card-content\n * - mat-card-actions\n * - mat-card-footer\n */\nvar MatCard = /** @class */ (function () {\n    function MatCard() {\n    }\nMatCard.ngComponentDef = ɵngcc0.ɵdefineComponent({ type: MatCard, selectors: [[\"mat-card\"]], factory: function MatCard_Factory(t) { return new (t || MatCard)(); }, hostBindings: function MatCard_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c12);\r\n    } }, exportAs: [\"matCard\"], ngContentSelectors: _c14, consts: 2, vars: 0, template: function MatCard_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵprojectionDef(_c13, _c14);\r\n        ɵngcc0.ɵprojection(0);\r\n        ɵngcc0.ɵprojection(1, 1);\r\n    } }, styles: [\".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:block;position:relative;padding:16px;border-radius:4px}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}@media screen and (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-actions,.mat-card-content,.mat-card-subtitle{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px 0}@media (max-width:599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child:not(.mat-card-footer),.mat-card>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child{margin-left:0;margin-right:0}.mat-card-title{margin-bottom:8px}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\"], encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCard, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-card',\r\n                exportAs: 'matCard',\r\n                template: \"<ng-content></ng-content><ng-content select=\\\"mat-card-footer\\\"></ng-content>\",\r\n                styles: [\".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:block;position:relative;padding:16px;border-radius:4px}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}@media screen and (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-actions,.mat-card-content,.mat-card-subtitle{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px 0}@media (max-width:599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child:not(.mat-card-footer),.mat-card>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child{margin-left:0;margin-right:0}.mat-card-title{margin-bottom:8px}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\"],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                host: { 'class': 'mat-card' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCard;\n}());\n/**\n * Component intended to be used within the `<mat-card>` component. It adds styles for a\n * preset header section (i.e. a title, subtitle, and avatar layout).\n * \\@docs-private\n */\nvar MatCardHeader = /** @class */ (function () {\n    function MatCardHeader() {\n    }\nMatCardHeader.ngComponentDef = ɵngcc0.ɵdefineComponent({ type: MatCardHeader, selectors: [[\"mat-card-header\"]], factory: function MatCardHeader_Factory(t) { return new (t || MatCardHeader)(); }, hostBindings: function MatCardHeader_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c15);\r\n    } }, ngContentSelectors: _c18, consts: 4, vars: 0, template: function MatCardHeader_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵprojectionDef(_c17, _c18);\r\n        ɵngcc0.ɵprojection(0, 1);\r\n        ɵngcc0.ɵelementStart(1, \"div\", _c16);\r\n        ɵngcc0.ɵprojection(2, 2);\r\n        ɵngcc0.ɵelementEnd();\r\n        ɵngcc0.ɵprojection(3);\r\n    } }, encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardHeader, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-card-header',\r\n                template: \"<ng-content select=\\\"[mat-card-avatar], [matCardAvatar]\\\"></ng-content><div class=\\\"mat-card-header-text\\\"><ng-content select=\\\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\\\"></ng-content></div><ng-content></ng-content>\",\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                host: { 'class': 'mat-card-header' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardHeader;\n}());\n/**\n * Component intended to be used within the `<mat-card>` component. It adds styles for a preset\n * layout that groups an image with a title section.\n * \\@docs-private\n */\nvar MatCardTitleGroup = /** @class */ (function () {\n    function MatCardTitleGroup() {\n    }\nMatCardTitleGroup.ngComponentDef = ɵngcc0.ɵdefineComponent({ type: MatCardTitleGroup, selectors: [[\"mat-card-title-group\"]], factory: function MatCardTitleGroup_Factory(t) { return new (t || MatCardTitleGroup)(); }, hostBindings: function MatCardTitleGroup_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c19);\r\n    } }, ngContentSelectors: _c21, consts: 4, vars: 0, template: function MatCardTitleGroup_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵprojectionDef(_c20, _c21);\r\n        ɵngcc0.ɵelementStart(0, \"div\");\r\n        ɵngcc0.ɵprojection(1, 1);\r\n        ɵngcc0.ɵelementEnd();\r\n        ɵngcc0.ɵprojection(2, 2);\r\n        ɵngcc0.ɵprojection(3);\r\n    } }, encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardTitleGroup, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-card-title-group',\r\n                template: \"<div><ng-content select=\\\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\\\"></ng-content></div><ng-content select=\\\"img\\\"></ng-content><ng-content></ng-content>\",\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                host: { 'class': 'mat-card-title-group' }\r\n            }]\r\n    }], function () { return []; }, null);\n    return MatCardTitleGroup;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MatCardModule = /** @class */ (function () {\n    function MatCardModule() {\n    }\nMatCardModule.ngModuleDef = ɵngcc0.ɵdefineNgModule({ type: MatCardModule });\n/*@__PURE__*/ ɵngcc0.ɵsetNgModuleScope(MatCardModule, { declarations: function () { return [MatCard,\r\n        MatCardHeader,\r\n        MatCardTitleGroup,\r\n        MatCardContent,\r\n        MatCardTitle,\r\n        MatCardSubtitle,\r\n        MatCardActions,\r\n        MatCardFooter,\r\n        MatCardSmImage,\r\n        MatCardMdImage,\r\n        MatCardLgImage,\r\n        MatCardImage,\r\n        MatCardXlImage,\r\n        MatCardAvatar]; }, imports: function () { return [MatCommonModule]; }, exports: function () { return [MatCard,\r\n        MatCardHeader,\r\n        MatCardTitleGroup,\r\n        MatCardContent,\r\n        MatCardTitle,\r\n        MatCardSubtitle,\r\n        MatCardActions,\r\n        MatCardFooter,\r\n        MatCardSmImage,\r\n        MatCardMdImage,\r\n        MatCardLgImage,\r\n        MatCardImage,\r\n        MatCardXlImage,\r\n        MatCardAvatar,\r\n        MatCommonModule]; } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatCardModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [MatCommonModule],\r\n                exports: [\r\n                    MatCard,\r\n                    MatCardHeader,\r\n                    MatCardTitleGroup,\r\n                    MatCardContent,\r\n                    MatCardTitle,\r\n                    MatCardSubtitle,\r\n                    MatCardActions,\r\n                    MatCardFooter,\r\n                    MatCardSmImage,\r\n                    MatCardMdImage,\r\n                    MatCardLgImage,\r\n                    MatCardImage,\r\n                    MatCardXlImage,\r\n                    MatCardAvatar,\r\n                    MatCommonModule,\r\n                ],\r\n                declarations: [\r\n                    MatCard, MatCardHeader, MatCardTitleGroup, MatCardContent, MatCardTitle, MatCardSubtitle,\r\n                    MatCardActions, MatCardFooter, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardImage,\r\n                    MatCardXlImage, MatCardAvatar,\r\n                ]\r\n            }]\r\n    }], function () { return []; }, null);\nMatCardModule.ngInjectorDef = ɵngcc0.defineInjector({ factory: function MatCardModule_Factory(t) { return new (t || MatCardModule)(); }, imports: [[MatCommonModule],\r\n        MatCommonModule] });\n    return MatCardModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { MatCardContent, MatCardTitle, MatCardSubtitle, MatCardActions, MatCardFooter, MatCardImage, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardXlImage, MatCardAvatar, MatCard, MatCardHeader, MatCardTitleGroup, MatCardModule };\n\n//# sourceMappingURL=card.es5.js.map","import * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/material/core';\nimport * as ɵngcc2 from '@angular/cdk/observers';\nimport * as ɵngcc3 from '@angular/cdk/a11y';\nimport * as ɵngcc4 from '@angular/common';\nimport * as ɵngcc5 from '@angular/cdk/portal';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Inject, InjectionToken, NgZone, TemplateRef, ChangeDetectionStrategy, Component, ContentChild, Input, ViewChild, ViewContainerRef, ViewEncapsulation, ChangeDetectorRef, Output, EventEmitter, Optional, ComponentFactoryResolver, forwardRef, ContentChildren, Attribute, NgModule } from '@angular/core';\nimport { __extends } from 'tslib';\nimport { CdkPortal, TemplatePortal, CdkPortalOutlet, PortalHostDirective, PortalModule } from '@angular/cdk/portal';\nimport { mixinDisabled, mixinDisableRipple, mixinColor, MAT_RIPPLE_GLOBAL_OPTIONS, mixinTabIndex, RippleRenderer, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { Subject, Subscription, merge, of } from 'rxjs';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { startWith, takeUntil } from 'rxjs/operators';\nimport { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { END, ENTER, HOME, SPACE } from '@angular/cdk/keycodes';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { FocusKeyManager, FocusMonitor, A11yModule } from '@angular/cdk/a11y';\nimport { Platform } from '@angular/cdk/platform';\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { CommonModule } from '@angular/common';\nconst _c0 = [1, \"mat-ink-bar\"];\nfunction MatTab_ng_template_0_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵprojection(0);\r\n} }\nconst _c1 = [];\nconst _c2 = [1, \"mat-tab-body\"];\nconst _c3 = [1, \"mat-tab-body-content\", 3];\nconst _c4 = [\"content\", \"\"];\nconst _c5 = [\"matTabBodyHost\", \"\"];\nfunction MatTabBody_ng_template_2_Template(rf, ctx) { }\nconst _c6 = [\"mat-tab-disabled\"];\nconst _c7 = [\"tabListContainer\"];\nconst _c8 = [\"tabList\"];\nconst _c9 = [1, \"mat-tab-header\"];\nconst _c10 = [\"mat-tab-header-pagination-controls-enabled\", \"mat-tab-header-rtl\"];\nconst _c11 = [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-before\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\"];\nconst _c12 = [1, \"mat-tab-header-pagination-chevron\"];\nconst _c13 = [1, \"mat-tab-label-container\", 3, \"keydown\"];\nconst _c14 = [\"tabListContainer\", \"\"];\nconst _c15 = [\"role\", \"tablist\", 1, \"mat-tab-list\", 3, \"cdkObserveContent\"];\nconst _c16 = [\"tabList\", \"\"];\nconst _c17 = [1, \"mat-tab-labels\"];\nconst _c18 = [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-after\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\"];\nconst _c19 = [\"mat-tab-header-pagination-disabled\"];\nconst _c20 = [\"tabBodyWrapper\"];\nconst _c21 = [\"tabHeader\"];\nconst _c22 = [1, \"mat-tab-group\"];\nconst _c23 = [\"mat-tab-group-dynamic-height\", \"mat-tab-group-inverted-header\"];\nconst _c24 = [3, \"selectedIndex\", \"disableRipple\", \"indexFocused\", \"selectFocusedIndex\"];\nconst _c25 = [\"tabHeader\", \"\"];\nconst _c26 = [\"class\", \"mat-tab-label\", \"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 3, \"id\", \"tabIndex\", \"aria-posinset\", \"aria-setsize\", \"aria-controls\", \"aria-selected\", \"aria-label\", \"aria-labelledby\", \"mat-tab-label-active\", \"disabled\", \"matRippleDisabled\", \"click\", 4, \"ngFor\", \"ngForOf\"];\nconst _c27 = [1, \"mat-tab-body-wrapper\"];\nconst _c28 = [\"tabBodyWrapper\", \"\"];\nconst _c29 = [\"role\", \"tabpanel\", 3, \"id\", \"aria-labelledby\", \"mat-tab-body-active\", \"content\", \"position\", \"origin\", \"_onCentered\", \"_onCentering\", 4, \"ngFor\", \"ngForOf\"];\nconst _c30 = [\"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 1, \"mat-tab-label\", 3, \"id\", \"tabIndex\", \"aria-posinset\", \"aria-setsize\", \"aria-controls\", \"aria-selected\", \"aria-label\", \"aria-labelledby\", \"disabled\", \"matRippleDisabled\", \"click\"];\nconst _c31 = [1, \"mat-tab-label-content\"];\nconst _c32 = [3, \"ngIf\"];\nconst _c33 = [3, \"cdkPortalOutlet\"];\nfunction MatTabGroup_div_2_ng_template_2_ng_template_0_Template(rf, ctx) { }\nfunction MatTabGroup_div_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵtemplate(0, MatTabGroup_div_2_ng_template_2_ng_template_0_Template, 0, 0, \"ng-template\", _c33);\r\n} if (rf & 2) {\r\n    const tab_r348 = ɵngcc0.ɵnextContext().$implicit;\r\n    ɵngcc0.ɵselect(0);\r\n    ɵngcc0.ɵelementProperty(0, \"cdkPortalOutlet\", ɵngcc0.ɵbind(tab_r348.templateLabel));\r\n} }\nfunction MatTabGroup_div_2_ng_template_3_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵtext(0);\r\n} if (rf & 2) {\r\n    const tab_r348 = ɵngcc0.ɵnextContext().$implicit;\r\n    ɵngcc0.ɵselect(0);\r\n    ɵngcc0.ɵtextBinding(0, ɵngcc0.ɵinterpolation1(\"\", tab_r348.textLabel, \"\"));\r\n} }\nconst _c34 = [\"mat-tab-label-active\"];\nfunction MatTabGroup_div_2_Template(rf, ctx) { if (rf & 1) {\r\n    const _r356 = ɵngcc0.ɵgetCurrentView();\r\n    ɵngcc0.ɵelementStart(0, \"div\", _c30);\r\n    ɵngcc0.ɵelementStyling(_c34);\r\n    ɵngcc0.ɵlistener(\"click\", function MatTabGroup_div_2_Template_div_click_0_listener($event) { ɵngcc0.ɵrestoreView(_r356); const tab_r348 = ctx.$implicit; const i_r349 = ctx.index; const ctx_r355 = ɵngcc0.ɵnextContext(); const _r344 = ɵngcc0.ɵreference(1); return ctx_r355._handleClick(tab_r348, _r344, i_r349); });\r\n    ɵngcc0.ɵelementStart(1, \"div\", _c31);\r\n    ɵngcc0.ɵtemplate(2, MatTabGroup_div_2_ng_template_2_Template, 1, 1, \"ng-template\", _c32);\r\n    ɵngcc0.ɵtemplate(3, MatTabGroup_div_2_ng_template_3_Template, 1, 1, \"ng-template\", _c32);\r\n    ɵngcc0.ɵelementEnd();\r\n    ɵngcc0.ɵelementEnd();\r\n} if (rf & 2) {\r\n    const tab_r348 = ctx.$implicit;\r\n    const i_r349 = ctx.index;\r\n    const ctx_r345 = ɵngcc0.ɵnextContext();\r\n    ɵngcc0.ɵelementClassProp(0, 0, (ctx_r345.selectedIndex == i_r349));\r\n    ɵngcc0.ɵelementStylingApply(0);\r\n    ɵngcc0.ɵselect(0);\r\n    ɵngcc0.ɵelementProperty(0, \"id\", ɵngcc0.ɵbind(ctx_r345._getTabLabelId(i_r349)));\r\n    ɵngcc0.ɵelementAttribute(0, \"tabIndex\", ɵngcc0.ɵbind(ctx_r345._getTabIndex(tab_r348, i_r349)));\r\n    ɵngcc0.ɵelementAttribute(0, \"aria-posinset\", ɵngcc0.ɵbind((i_r349 + 1)));\r\n    ɵngcc0.ɵelementAttribute(0, \"aria-setsize\", ɵngcc0.ɵbind(ctx_r345._tabs.length));\r\n    ɵngcc0.ɵelementAttribute(0, \"aria-controls\", ɵngcc0.ɵbind(ctx_r345._getTabContentId(i_r349)));\r\n    ɵngcc0.ɵelementAttribute(0, \"aria-selected\", ɵngcc0.ɵbind((ctx_r345.selectedIndex == i_r349)));\r\n    ɵngcc0.ɵelementAttribute(0, \"aria-label\", ɵngcc0.ɵbind((tab_r348.ariaLabel || null)));\r\n    ɵngcc0.ɵelementAttribute(0, \"aria-labelledby\", ɵngcc0.ɵbind(((!tab_r348.ariaLabel && tab_r348.ariaLabelledby) ? tab_r348.ariaLabelledby : null)));\r\n    ɵngcc0.ɵelementProperty(0, \"disabled\", ɵngcc0.ɵbind(tab_r348.disabled));\r\n    ɵngcc0.ɵelementProperty(0, \"matRippleDisabled\", ɵngcc0.ɵbind((tab_r348.disabled || ctx_r345.disableRipple)));\r\n    ɵngcc0.ɵselect(2);\r\n    ɵngcc0.ɵelementProperty(2, \"ngIf\", ɵngcc0.ɵbind(tab_r348.templateLabel));\r\n    ɵngcc0.ɵselect(3);\r\n    ɵngcc0.ɵelementProperty(3, \"ngIf\", ɵngcc0.ɵbind(!tab_r348.templateLabel));\r\n} }\nconst _c35 = [\"role\", \"tabpanel\", 3, \"id\", \"aria-labelledby\", \"content\", \"position\", \"origin\", \"_onCentered\", \"_onCentering\"];\nconst _c36 = [\"mat-tab-body-active\"];\nfunction MatTabGroup_mat_tab_body_5_Template(rf, ctx) { if (rf & 1) {\r\n    const _r360 = ɵngcc0.ɵgetCurrentView();\r\n    ɵngcc0.ɵelementStart(0, \"mat-tab-body\", _c35);\r\n    ɵngcc0.ɵelementStyling(_c36);\r\n    ɵngcc0.ɵlistener(\"_onCentered\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentered_0_listener($event) { ɵngcc0.ɵrestoreView(_r360); const ctx_r359 = ɵngcc0.ɵnextContext(); return ctx_r359._removeTabBodyWrapperHeight(); });\r\n    ɵngcc0.ɵlistener(\"_onCentering\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentering_0_listener($event) { ɵngcc0.ɵrestoreView(_r360); const ctx_r361 = ɵngcc0.ɵnextContext(); return ctx_r361._setTabBodyWrapperHeight($event); });\r\n    ɵngcc0.ɵelementEnd();\r\n} if (rf & 2) {\r\n    const tab_r357 = ctx.$implicit;\r\n    const i_r358 = ctx.index;\r\n    const ctx_r347 = ɵngcc0.ɵnextContext();\r\n    ɵngcc0.ɵelementClassProp(0, 0, (ctx_r347.selectedIndex == i_r358));\r\n    ɵngcc0.ɵelementStylingApply(0);\r\n    ɵngcc0.ɵselect(0);\r\n    ɵngcc0.ɵelementProperty(0, \"id\", ɵngcc0.ɵbind(ctx_r347._getTabContentId(i_r358)));\r\n    ɵngcc0.ɵelementAttribute(0, \"aria-labelledby\", ɵngcc0.ɵbind(ctx_r347._getTabLabelId(i_r358)));\r\n    ɵngcc0.ɵelementProperty(0, \"content\", ɵngcc0.ɵbind(tab_r357.content));\r\n    ɵngcc0.ɵelementProperty(0, \"position\", ɵngcc0.ɵbind(tab_r357.position));\r\n    ɵngcc0.ɵelementProperty(0, \"origin\", ɵngcc0.ɵbind(tab_r357.origin));\r\n} }\nconst _c37 = [1, \"mat-tab-nav-bar\"];\nconst _c38 = [\"mat-tab-nav-bar\", \"\"];\nconst _c39 = [1, \"mat-tab-links\", 3, \"cdkObserveContent\"];\nconst _c40 = [1, \"mat-tab-link\"];\nconst _c41 = [\"mat-tab-disabled\", \"mat-tab-label-active\"];\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Injection token for the MatInkBar's Positioner.\n  @type {?} */\nvar _MAT_INK_BAR_POSITIONER = new InjectionToken('MatInkBarPositioner', {\n    providedIn: 'root',\n    factory: _MAT_INK_BAR_POSITIONER_FACTORY\n});\n/**\n * The default positioner function for the MatInkBar.\n * \\@docs-private\n * @return {?}\n */\nfunction _MAT_INK_BAR_POSITIONER_FACTORY() {\n    /** @type {?} */\n    var method = function (element) { return ({\n        left: element ? (element.offsetLeft || 0) + 'px' : '0',\n        width: element ? (element.offsetWidth || 0) + 'px' : '0',\n    }); };\n    return method;\n}\n/**\n * The ink-bar is used to display and animate the line underneath the current active tab label.\n * \\@docs-private\n */\nvar MatInkBar = /** @class */ (function () {\n    function MatInkBar(_elementRef, _ngZone, _inkBarPositioner) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._inkBarPositioner = _inkBarPositioner;\n    }\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param element\n     */\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param {?} element\n     * @return {?}\n     */\n    MatInkBar.prototype.alignToElement = /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        var _this = this;\n        this.show();\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(function () {\n                requestAnimationFrame(function () { return _this._setStyles(element); });\n            });\n        }\n        else {\n            this._setStyles(element);\n        }\n    };\n    /** Shows the ink bar. */\n    /**\n     * Shows the ink bar.\n     * @return {?}\n     */\n    MatInkBar.prototype.show = /**\n     * Shows the ink bar.\n     * @return {?}\n     */\n    function () {\n        this._elementRef.nativeElement.style.visibility = 'visible';\n    };\n    /** Hides the ink bar. */\n    /**\n     * Hides the ink bar.\n     * @return {?}\n     */\n    MatInkBar.prototype.hide = /**\n     * Hides the ink bar.\n     * @return {?}\n     */\n    function () {\n        this._elementRef.nativeElement.style.visibility = 'hidden';\n    };\n    /**\n     * Sets the proper styles to the ink bar element.\n     * @param {?} element\n     * @return {?}\n     */\n    MatInkBar.prototype._setStyles = /**\n     * Sets the proper styles to the ink bar element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        /** @type {?} */\n        var positions = this._inkBarPositioner(element);\n        /** @type {?} */\n        var inkBar = this._elementRef.nativeElement;\n        inkBar.style.left = positions.left;\n        inkBar.style.width = positions.width;\n    };\n    /** @nocollapse */\n    MatInkBar.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: NgZone },\n        { type: undefined, decorators: [{ type: Inject, args: [_MAT_INK_BAR_POSITIONER,] }] }\n    ]; };\nMatInkBar.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatInkBar, selectors: [[\"mat-ink-bar\"]], factory: function MatInkBar_Factory(t) { return new (t || MatInkBar)(ɵngcc0.ɵdirectiveInject(ElementRef), ɵngcc0.ɵdirectiveInject(NgZone), ɵngcc0.ɵdirectiveInject(_MAT_INK_BAR_POSITIONER)); }, hostBindings: function MatInkBar_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c0);\r\n    } } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatInkBar, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'mat-ink-bar',\r\n                host: {\r\n                    'class': 'mat-ink-bar'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: NgZone }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [_MAT_INK_BAR_POSITIONER]\r\n            }] }]; }, { _elementRef: [], _ngZone: [], _inkBarPositioner: [], alignToElement: [], show: [], hide: [], _setStyles: [] });\n    return MatInkBar;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Decorates the `ng-template` tags and reads out the template from it.\n */\nvar MatTabContent = /** @class */ (function () {\n    function MatTabContent(template) {\n        this.template = template;\n    }\n    /** @nocollapse */\n    MatTabContent.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\nMatTabContent.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatTabContent, selectors: [[\"\", \"matTabContent\", \"\"]], factory: function MatTabContent_Factory(t) { return new (t || MatTabContent)(ɵngcc0.ɵdirectiveInject(TemplateRef)); } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabContent, [{\r\n        type: Directive,\r\n        args: [{ selector: '[matTabContent]' }]\r\n    }], function () { return [{ type: TemplateRef }]; }, { template: [] });\n    return MatTabContent;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar _CdkPortal = CdkPortal;\n/**\n * Used to flag tab labels for use with the portal directive\n */\nvar MatTabLabel = /** @class */ (function (_super) {\n    __extends(MatTabLabel, _super);\n    function MatTabLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\nMatTabLabel.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatTabLabel, selectors: [[\"\", \"mat-tab-label\", \"\"], [\"\", \"matTabLabel\", \"\"]], factory: function MatTabLabel_Factory(t) { return ɵMatTabLabel_BaseFactory((t || MatTabLabel)); }, features: [ɵngcc0.ɵInheritDefinitionFeature] });\nconst ɵMatTabLabel_BaseFactory = ɵngcc0.ɵgetInheritedFactory(MatTabLabel);\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabLabel, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-tab-label], [matTabLabel]'\r\n            }]\r\n    }], null, null);\n    return MatTabLabel;\n}(_CdkPortal));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabBase = /** @class */ (function () {\n    function MatTabBase() {\n    }\n    return MatTabBase;\n}());\n/** @type {?} */\nvar _MatTabMixinBase = mixinDisabled(MatTabBase);\nvar MatTab = /** @class */ (function (_super) {\n    __extends(MatTab, _super);\n    function MatTab(_viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Plain text label for the tab, used when there is no template label.\n         */\n        _this.textLabel = '';\n        /**\n         * Portal that will be the hosted content of the tab\n         */\n        _this._contentPortal = null;\n        /**\n         * Emits whenever the internal state of the tab changes.\n         */\n        _this._stateChanges = new Subject();\n        /**\n         * The relatively indexed position where 0 represents the center, negative is left, and positive\n         * represents the right.\n         */\n        _this.position = null;\n        /**\n         * The initial relatively index origin of the tab if it was created and selected after there\n         * was already a selected tab. Provides context of what position the tab should originate from.\n         */\n        _this.origin = null;\n        /**\n         * Whether the tab is currently active.\n         */\n        _this.isActive = false;\n        return _this;\n    }\n    Object.defineProperty(MatTab.prototype, \"content\", {\n        /** @docs-private */\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this._contentPortal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MatTab.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n            this._stateChanges.next();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTab.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._stateChanges.complete();\n    };\n    /**\n     * @return {?}\n     */\n    MatTab.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._contentPortal = new TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);\n    };\n    /** @nocollapse */\n    MatTab.ctorParameters = function () { return [\n        { type: ViewContainerRef }\n    ]; };\n    MatTab.propDecorators = {\n        templateLabel: [{ type: ContentChild, args: [MatTabLabel,] }],\n        _explicitContent: [{ type: ContentChild, args: [MatTabContent, { read: TemplateRef },] }],\n        _implicitContent: [{ type: ViewChild, args: [TemplateRef,] }],\n        textLabel: [{ type: Input, args: ['label',] }],\n        ariaLabel: [{ type: Input, args: ['aria-label',] }],\n        ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }]\n    };\nMatTab.ngComponentDef = ɵngcc0.ɵdefineComponent({ type: MatTab, selectors: [[\"mat-tab\"]], factory: function MatTab_Factory(t) { return new (t || MatTab)(ɵngcc0.ɵdirectiveInject(ViewContainerRef)); }, contentQueries: function MatTab_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵcontentQuery(dirIndex, MatTabLabel, true, null);\r\n        ɵngcc0.ɵcontentQuery(dirIndex, MatTabContent, true, TemplateRef);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadContentQuery()) && (ctx.templateLabel = _t.first));\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadContentQuery()) && (ctx._explicitContent = _t.first));\r\n    } }, viewQuery: function MatTab_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵviewQuery(TemplateRef, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadViewQuery()) && (ctx._implicitContent = _t.first));\r\n    } }, inputs: { disabled: \"disabled\", textLabel: [\"label\", \"textLabel\"], ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"] }, exportAs: [\"matTab\"], features: [ɵngcc0.ɵInheritDefinitionFeature, ɵngcc0.ɵNgOnChangesFeature()], ngContentSelectors: _c1, consts: 1, vars: 0, template: function MatTab_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵprojectionDef();\r\n        ɵngcc0.ɵtemplate(0, MatTab_ng_template_0_Template, 1, 0, \"ng-template\");\r\n    } }, encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTab, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-tab',\r\n                template: \"<ng-template><ng-content></ng-content></ng-template>\",\r\n                inputs: ['disabled'],\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                exportAs: 'matTab'\r\n            }]\r\n    }], function () { return [{ type: ViewContainerRef }]; }, { content: [], ngOnChanges: [], ngOnDestroy: [], ngOnInit: [], _contentPortal: [], templateLabel: [{\r\n            type: ContentChild,\r\n            args: [MatTabLabel]\r\n        }], _explicitContent: [{\r\n            type: ContentChild,\r\n            args: [MatTabContent, { read: TemplateRef }]\r\n        }], _implicitContent: [{\r\n            type: ViewChild,\r\n            args: [TemplateRef]\r\n        }], textLabel: [{\r\n            type: Input,\r\n            args: ['label']\r\n        }], ariaLabel: [{\r\n            type: Input,\r\n            args: ['aria-label']\r\n        }], ariaLabelledby: [{\r\n            type: Input,\r\n            args: ['aria-labelledby']\r\n        }] });\n    return MatTab;\n}(_MatTabMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Animations used by the Material tabs.\n * \\@docs-private\n  @type {?} */\nvar matTabsAnimations = {\n    /** Animation translates a tab along the X axis. */\n    translateTab: trigger('translateTab', [\n        // Note: transitions to `none` instead of 0, because some browsers might blur the content.\n        state('center, void, left-origin-center, right-origin-center', style({ transform: 'none' })),\n        // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n        // in order to ensure that the element has a height before its state changes. This is\n        // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n        // not have a static height and is not rendered. See related issue: #9465\n        state('left', style({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),\n        state('right', style({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),\n        transition('* => left, * => right, left => center, right => center', animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')),\n        transition('void => left-origin-center', [\n            style({ transform: 'translate3d(-100%, 0, 0)' }),\n            animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')\n        ]),\n        transition('void => right-origin-center', [\n            style({ transform: 'translate3d(100%, 0, 0)' }),\n            animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')\n        ])\n    ])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * The portal host directive for the contents of the tab.\n * \\@docs-private\n */\nvar MatTabBodyPortal = /** @class */ (function (_super) {\n    __extends(MatTabBodyPortal, _super);\n    function MatTabBodyPortal(componentFactoryResolver, viewContainerRef, _host) {\n        var _this = _super.call(this, componentFactoryResolver, viewContainerRef) || this;\n        _this._host = _host;\n        /**\n         * Subscription to events for when the tab body begins centering.\n         */\n        _this._centeringSub = Subscription.EMPTY;\n        /**\n         * Subscription to events for when the tab body finishes leaving from center position.\n         */\n        _this._leavingSub = Subscription.EMPTY;\n        return _this;\n    }\n    /** Set initial visibility or set up subscription for changing visibility. */\n    /**\n     * Set initial visibility or set up subscription for changing visibility.\n     * @return {?}\n     */\n    MatTabBodyPortal.prototype.ngOnInit = /**\n     * Set initial visibility or set up subscription for changing visibility.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._centeringSub = this._host._beforeCentering\n            .pipe(startWith(this._host._isCenterPosition(this._host._position)))\n            .subscribe(function (isCentering) {\n            if (isCentering && !_this.hasAttached()) {\n                _this.attach(_this._host._content);\n            }\n        });\n        this._leavingSub = this._host._afterLeavingCenter.subscribe(function () {\n            _this.detach();\n        });\n    };\n    /** Clean up centering subscription. */\n    /**\n     * Clean up centering subscription.\n     * @return {?}\n     */\n    MatTabBodyPortal.prototype.ngOnDestroy = /**\n     * Clean up centering subscription.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.ngOnDestroy.call(this);\n        this._centeringSub.unsubscribe();\n        this._leavingSub.unsubscribe();\n    };\n    /** @nocollapse */\n    MatTabBodyPortal.ctorParameters = function () { return [\n        { type: ComponentFactoryResolver },\n        { type: ViewContainerRef },\n        { type: MatTabBody, decorators: [{ type: Inject, args: [forwardRef(function () { return MatTabBody; }),] }] }\n    ]; };\nMatTabBodyPortal.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatTabBodyPortal, selectors: [[\"\", \"matTabBodyHost\", \"\"]], factory: function MatTabBodyPortal_Factory(t) { return new (t || MatTabBodyPortal)(ɵngcc0.ɵdirectiveInject(ComponentFactoryResolver), ɵngcc0.ɵdirectiveInject(ViewContainerRef), ɵngcc0.ɵdirectiveInject(forwardRef(function () { return MatTabBody; }))); }, features: [ɵngcc0.ɵInheritDefinitionFeature] });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabBodyPortal, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[matTabBodyHost]'\r\n            }]\r\n    }], function () { return [{ type: ComponentFactoryResolver }, { type: ViewContainerRef }, { type: MatTabBody, decorators: [{\r\n                type: Inject,\r\n                args: [forwardRef(function () { return MatTabBody; })]\r\n            }] }]; }, { ngOnInit: [], _centeringSub: [], _leavingSub: [], ngOnDestroy: [] });\n    return MatTabBodyPortal;\n}(CdkPortalOutlet));\n/**\n * Wrapper for the contents of a tab.\n * \\@docs-private\n */\nvar MatTabBody = /** @class */ (function () {\n    function MatTabBody(_elementRef, _dir, /**\n                   * @breaking-change 8.0.0 changeDetectorRef to be made required.\n                   */\n    changeDetectorRef) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._dir = _dir;\n        /**\n         * Subscription to the directionality change observable.\n         */\n        this._dirChangeSubscription = Subscription.EMPTY;\n        /**\n         * Event emitted when the tab begins to animate towards the center as the active tab.\n         */\n        this._onCentering = new EventEmitter();\n        /**\n         * Event emitted before the centering of the tab begins.\n         */\n        this._beforeCentering = new EventEmitter();\n        /**\n         * Event emitted before the centering of the tab begins.\n         */\n        this._afterLeavingCenter = new EventEmitter();\n        /**\n         * Event emitted when the tab completes its animation towards the center.\n         */\n        this._onCentered = new EventEmitter(true);\n        if (this._dir && changeDetectorRef) {\n            this._dirChangeSubscription = this._dir.change.subscribe(function (dir) {\n                _this._computePositionAnimationState(dir);\n                changeDetectorRef.markForCheck();\n            });\n        }\n    }\n    Object.defineProperty(MatTabBody.prototype, \"position\", {\n        /** The shifted index position of the tab body, where zero represents the active center tab. */\n        set: /**\n         * The shifted index position of the tab body, where zero represents the active center tab.\n         * @param {?} position\n         * @return {?}\n         */\n        function (position) {\n            this._positionIndex = position;\n            this._computePositionAnimationState();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     */\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     * @return {?}\n     */\n    MatTabBody.prototype.ngOnInit = /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     * @return {?}\n     */\n    function () {\n        if (this._position == 'center' && this.origin != null) {\n            this._position = this._computePositionFromOrigin();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTabBody.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._dirChangeSubscription.unsubscribe();\n    };\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    MatTabBody.prototype._onTranslateTabStarted = /**\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) {\n        /** @type {?} */\n        var isCentering = this._isCenterPosition(e.toState);\n        this._beforeCentering.emit(isCentering);\n        if (isCentering) {\n            this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n        }\n    };\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    MatTabBody.prototype._onTranslateTabComplete = /**\n     * @param {?} e\n     * @return {?}\n     */\n    function (e) {\n        // If the transition to the center is complete, emit an event.\n        if (this._isCenterPosition(e.toState) && this._isCenterPosition(this._position)) {\n            this._onCentered.emit();\n        }\n        if (this._isCenterPosition(e.fromState) && !this._isCenterPosition(this._position)) {\n            this._afterLeavingCenter.emit();\n        }\n    };\n    /** The text direction of the containing app. */\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    MatTabBody.prototype._getLayoutDirection = /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    function () {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    };\n    /** Whether the provided position state is considered center, regardless of origin. */\n    /**\n     * Whether the provided position state is considered center, regardless of origin.\n     * @param {?} position\n     * @return {?}\n     */\n    MatTabBody.prototype._isCenterPosition = /**\n     * Whether the provided position state is considered center, regardless of origin.\n     * @param {?} position\n     * @return {?}\n     */\n    function (position) {\n        return position == 'center' ||\n            position == 'left-origin-center' ||\n            position == 'right-origin-center';\n    };\n    /**\n     * Computes the position state that will be used for the tab-body animation trigger.\n     * @param {?=} dir\n     * @return {?}\n     */\n    MatTabBody.prototype._computePositionAnimationState = /**\n     * Computes the position state that will be used for the tab-body animation trigger.\n     * @param {?=} dir\n     * @return {?}\n     */\n    function (dir) {\n        if (dir === void 0) { dir = this._getLayoutDirection(); }\n        if (this._positionIndex < 0) {\n            this._position = dir == 'ltr' ? 'left' : 'right';\n        }\n        else if (this._positionIndex > 0) {\n            this._position = dir == 'ltr' ? 'right' : 'left';\n        }\n        else {\n            this._position = 'center';\n        }\n    };\n    /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     * @return {?}\n     */\n    MatTabBody.prototype._computePositionFromOrigin = /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var dir = this._getLayoutDirection();\n        if ((dir == 'ltr' && this.origin <= 0) || (dir == 'rtl' && this.origin > 0)) {\n            return 'left-origin-center';\n        }\n        return 'right-origin-center';\n    };\n    /** @nocollapse */\n    MatTabBody.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Directionality, decorators: [{ type: Optional }] },\n        { type: ChangeDetectorRef }\n    ]; };\n    MatTabBody.propDecorators = {\n        _onCentering: [{ type: Output }],\n        _beforeCentering: [{ type: Output }],\n        _afterLeavingCenter: [{ type: Output }],\n        _onCentered: [{ type: Output }],\n        _portalHost: [{ type: ViewChild, args: [PortalHostDirective,] }],\n        _content: [{ type: Input, args: ['content',] }],\n        origin: [{ type: Input }],\n        position: [{ type: Input }]\n    };\nMatTabBody.ngComponentDef = ɵngcc0.ɵdefineComponent({ type: MatTabBody, selectors: [[\"mat-tab-body\"]], factory: function MatTabBody_Factory(t) { return new (t || MatTabBody)(ɵngcc0.ɵdirectiveInject(ElementRef), ɵngcc0.ɵdirectiveInject(Directionality, 8), ɵngcc0.ɵdirectiveInject(ChangeDetectorRef)); }, viewQuery: function MatTabBody_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵviewQuery(PortalHostDirective, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadViewQuery()) && (ctx._portalHost = _t.first));\r\n    } }, hostBindings: function MatTabBody_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c2);\r\n    } }, inputs: { position: \"position\", _content: [\"content\", \"_content\"], origin: \"origin\" }, outputs: { _onCentering: \"_onCentering\", _beforeCentering: \"_beforeCentering\", _afterLeavingCenter: \"_afterLeavingCenter\", _onCentered: \"_onCentered\" }, consts: 3, vars: 1, template: function MatTabBody_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵelementStart(0, \"div\", _c3, _c4);\r\n        ɵngcc0.ɵlistener(\"@translateTab.start\", function MatTabBody_Template_div_animation_translateTab_start_0_listener($event) { return ctx._onTranslateTabStarted($event); });\r\n        ɵngcc0.ɵlistener(\"@translateTab.done\", function MatTabBody_Template_div_animation_translateTab_done_0_listener($event) { return ctx._onTranslateTabComplete($event); });\r\n        ɵngcc0.ɵtemplate(2, MatTabBody_ng_template_2_Template, 0, 0, \"ng-template\", _c5);\r\n        ɵngcc0.ɵelementEnd();\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵselect(0);\r\n        ɵngcc0.ɵelementProperty(0, \"@translateTab\", ɵngcc0.ɵbind(ctx._position));\r\n    } }, directives: [MatTabBodyPortal], styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\"], encapsulation: 2, data: { animation: [matTabsAnimations.translateTab] }, changeDetection: 0 });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabBody, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-tab-body',\r\n                template: \"<div class=\\\"mat-tab-body-content\\\" #content [@translateTab]=\\\"_position\\\" (@translateTab.start)=\\\"_onTranslateTabStarted($event)\\\" (@translateTab.done)=\\\"_onTranslateTabComplete($event)\\\"><ng-template matTabBodyHost></ng-template></div>\",\r\n                styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\"],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                animations: [matTabsAnimations.translateTab],\r\n                host: {\r\n                    'class': 'mat-tab-body'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: ChangeDetectorRef }]; }, { _elementRef: [], _dir: [], _dirChangeSubscription: [], _onCentering: [{\r\n            type: Output\r\n        }], _beforeCentering: [{\r\n            type: Output\r\n        }], _afterLeavingCenter: [{\r\n            type: Output\r\n        }], _onCentered: [{\r\n            type: Output\r\n        }], position: [{\r\n            type: Input\r\n        }], ngOnInit: [], _position: [], ngOnDestroy: [], _onTranslateTabStarted: [], _onTranslateTabComplete: [], _getLayoutDirection: [], _isCenterPosition: [], _computePositionAnimationState: [], _computePositionFromOrigin: [], _portalHost: [{\r\n            type: ViewChild,\r\n            args: [PortalHostDirective]\r\n        }], _content: [{\r\n            type: Input,\r\n            args: ['content']\r\n        }], origin: [{\r\n            type: Input\r\n        }] });\n    return MatTabBody;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabLabelWrapperBase = /** @class */ (function () {\n    function MatTabLabelWrapperBase() {\n    }\n    return MatTabLabelWrapperBase;\n}());\n/** @type {?} */\nvar _MatTabLabelWrapperMixinBase = mixinDisabled(MatTabLabelWrapperBase);\n/**\n * Used in the `mat-tab-group` view to display tab labels.\n * \\@docs-private\n */\nvar MatTabLabelWrapper = /** @class */ (function (_super) {\n    __extends(MatTabLabelWrapper, _super);\n    function MatTabLabelWrapper(elementRef) {\n        var _this = _super.call(this) || this;\n        _this.elementRef = elementRef;\n        return _this;\n    }\n    /** Sets focus on the wrapper element */\n    /**\n     * Sets focus on the wrapper element\n     * @return {?}\n     */\n    MatTabLabelWrapper.prototype.focus = /**\n     * Sets focus on the wrapper element\n     * @return {?}\n     */\n    function () {\n        this.elementRef.nativeElement.focus();\n    };\n    /**\n     * @return {?}\n     */\n    MatTabLabelWrapper.prototype.getOffsetLeft = /**\n     * @return {?}\n     */\n    function () {\n        return this.elementRef.nativeElement.offsetLeft;\n    };\n    /**\n     * @return {?}\n     */\n    MatTabLabelWrapper.prototype.getOffsetWidth = /**\n     * @return {?}\n     */\n    function () {\n        return this.elementRef.nativeElement.offsetWidth;\n    };\n    /** @nocollapse */\n    MatTabLabelWrapper.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\nMatTabLabelWrapper.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatTabLabelWrapper, selectors: [[\"\", \"matTabLabelWrapper\", \"\"]], factory: function MatTabLabelWrapper_Factory(t) { return new (t || MatTabLabelWrapper)(ɵngcc0.ɵdirectiveInject(ElementRef)); }, hostBindings: function MatTabLabelWrapper_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵallocHostVars(1);\r\n        ɵngcc0.ɵelementHostStyling(_c6);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵelementAttribute(elIndex, \"aria-disabled\", ɵngcc0.ɵbind(!!ctx.disabled));\r\n        ɵngcc0.ɵelementHostClassProp(0, ctx.disabled);\r\n        ɵngcc0.ɵelementHostStylingApply();\r\n    } }, inputs: { disabled: \"disabled\" }, features: [ɵngcc0.ɵInheritDefinitionFeature] });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabLabelWrapper, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[matTabLabelWrapper]',\r\n                inputs: ['disabled'],\r\n                host: {\r\n                    '[class.mat-tab-disabled]': 'disabled',\r\n                    '[attr.aria-disabled]': '!!disabled'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }]; }, { focus: [], getOffsetLeft: [], getOffsetWidth: [] });\n    return MatTabLabelWrapper;\n}(_MatTabLabelWrapperMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n  @type {?} */\nvar EXAGGERATED_OVERSCROLL = 60;\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabHeaderBase = /** @class */ (function () {\n    function MatTabHeaderBase() {\n    }\n    return MatTabHeaderBase;\n}());\n/** @type {?} */\nvar _MatTabHeaderMixinBase = mixinDisableRipple(MatTabHeaderBase);\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * \\@docs-private\n */\nvar MatTabHeader = /** @class */ (function (_super) {\n    __extends(MatTabHeader, _super);\n    function MatTabHeader(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone) {\n        var _this = _super.call(this) || this;\n        _this._elementRef = _elementRef;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._viewportRuler = _viewportRuler;\n        _this._dir = _dir;\n        _this._ngZone = _ngZone;\n        /**\n         * The distance in pixels that the tab labels should be translated to the left.\n         */\n        _this._scrollDistance = 0;\n        /**\n         * Whether the header should scroll to the selected index after the view has been checked.\n         */\n        _this._selectedIndexChanged = false;\n        /**\n         * Emits when the component is destroyed.\n         */\n        _this._destroyed = new Subject();\n        /**\n         * Whether the controls for pagination should be displayed\n         */\n        _this._showPaginationControls = false;\n        /**\n         * Whether the tab list can be scrolled more towards the end of the tab label list.\n         */\n        _this._disableScrollAfter = true;\n        /**\n         * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n         */\n        _this._disableScrollBefore = true;\n        _this._selectedIndex = 0;\n        /**\n         * Event emitted when the option is selected.\n         */\n        _this.selectFocusedIndex = new EventEmitter();\n        /**\n         * Event emitted when a label is focused.\n         */\n        _this.indexFocused = new EventEmitter();\n        return _this;\n    }\n    Object.defineProperty(MatTabHeader.prototype, \"selectedIndex\", {\n        /** The index of the active tab. */\n        get: /**\n         * The index of the active tab.\n         * @return {?}\n         */\n        function () { return this._selectedIndex; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            value = coerceNumberProperty(value);\n            this._selectedIndexChanged = this._selectedIndex != value;\n            this._selectedIndex = value;\n            if (this._keyManager) {\n                this._keyManager.updateActiveItemIndex(value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngAfterContentChecked = /**\n     * @return {?}\n     */\n    function () {\n        // If the number of tab labels have changed, check if scrolling should be enabled\n        if (this._tabLabelCount != this._labelWrappers.length) {\n            this._updatePagination();\n            this._tabLabelCount = this._labelWrappers.length;\n            this._changeDetectorRef.markForCheck();\n        }\n        // If the selected index has changed, scroll to the label and check if the scrolling controls\n        // should be disabled.\n        if (this._selectedIndexChanged) {\n            this._scrollToLabel(this._selectedIndex);\n            this._checkScrollingControls();\n            this._alignInkBarToSelectedTab();\n            this._selectedIndexChanged = false;\n            this._changeDetectorRef.markForCheck();\n        }\n        // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n        // then translate the header to reflect this.\n        if (this._scrollDistanceChanged) {\n            this._updateTabScrollPosition();\n            this._scrollDistanceChanged = false;\n            this._changeDetectorRef.markForCheck();\n        }\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatTabHeader.prototype._handleKeydown = /**\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        switch (event.keyCode) {\n            case HOME:\n                this._keyManager.setFirstItemActive();\n                event.preventDefault();\n                break;\n            case END:\n                this._keyManager.setLastItemActive();\n                event.preventDefault();\n                break;\n            case ENTER:\n            case SPACE:\n                this.selectFocusedIndex.emit(this.focusIndex);\n                event.preventDefault();\n                break;\n            default:\n                this._keyManager.onKeydown(event);\n        }\n    };\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     */\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngAfterContentInit = /**\n     * Aligns the ink bar to the selected tab on load.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var dirChange = this._dir ? this._dir.change : of(null);\n        /** @type {?} */\n        var resize = this._viewportRuler.change(150);\n        /** @type {?} */\n        var realign = function () {\n            _this._updatePagination();\n            _this._alignInkBarToSelectedTab();\n        };\n        this._keyManager = new FocusKeyManager(this._labelWrappers)\n            .withHorizontalOrientation(this._getLayoutDirection())\n            .withWrap();\n        this._keyManager.updateActiveItem(0);\n        // Defer the first call in order to allow for slower browsers to lay out the elements.\n        // This helps in cases where the user lands directly on a page with paginated tabs.\n        typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n        // On dir change or window resize, realign the ink bar and update the orientation of\n        // the key manager if the direction has changed.\n        merge(dirChange, resize).pipe(takeUntil(this._destroyed)).subscribe(function () {\n            realign();\n            _this._keyManager.withHorizontalOrientation(_this._getLayoutDirection());\n        });\n        // If there is a change in the focus key manager we need to emit the `indexFocused`\n        // event in order to provide a public event that notifies about focus changes. Also we realign\n        // the tabs container by scrolling the new focused tab into the visible section.\n        this._keyManager.change.pipe(takeUntil(this._destroyed)).subscribe(function (newFocusIndex) {\n            _this.indexFocused.emit(newFocusIndex);\n            _this._setTabFocus(newFocusIndex);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyed.next();\n        this._destroyed.complete();\n    };\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     */\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     * @return {?}\n     */\n    MatTabHeader.prototype._onContentChanges = /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var zoneCallback = function () {\n            _this._updatePagination();\n            _this._alignInkBarToSelectedTab();\n            _this._changeDetectorRef.markForCheck();\n        };\n        // The content observer runs outside the `NgZone` by default, which\n        // means that we need to bring the callback back in ourselves.\n        // @breaking-change 8.0.0 Remove null check for `_ngZone` once it's a required parameter.\n        this._ngZone ? this._ngZone.run(zoneCallback) : zoneCallback();\n    };\n    /**\n     * Updating the view whether pagination should be enabled or not\n     */\n    /**\n     * Updating the view whether pagination should be enabled or not\n     * @return {?}\n     */\n    MatTabHeader.prototype._updatePagination = /**\n     * Updating the view whether pagination should be enabled or not\n     * @return {?}\n     */\n    function () {\n        this._checkPaginationEnabled();\n        this._checkScrollingControls();\n        this._updateTabScrollPosition();\n    };\n    Object.defineProperty(MatTabHeader.prototype, \"focusIndex\", {\n        /** Tracks which element has focus; used for keyboard navigation */\n        get: /**\n         * Tracks which element has focus; used for keyboard navigation\n         * @return {?}\n         */\n        function () {\n            return this._keyManager ? /** @type {?} */ ((this._keyManager.activeItemIndex)) : 0;\n        },\n        /** When the focus index is set, we must manually send focus to the correct label */\n        set: /**\n         * When the focus index is set, we must manually send focus to the correct label\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n                return;\n            }\n            this._keyManager.setActiveItem(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     */\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabHeader.prototype._isValidIndex = /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (!this._labelWrappers) {\n            return true;\n        }\n        /** @type {?} */\n        var tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n        return !!tab && !tab.disabled;\n    };\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     */\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     * @param {?} tabIndex\n     * @return {?}\n     */\n    MatTabHeader.prototype._setTabFocus = /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     * @param {?} tabIndex\n     * @return {?}\n     */\n    function (tabIndex) {\n        if (this._showPaginationControls) {\n            this._scrollToLabel(tabIndex);\n        }\n        if (this._labelWrappers && this._labelWrappers.length) {\n            this._labelWrappers.toArray()[tabIndex].focus();\n            /** @type {?} */\n            var containerEl = this._tabListContainer.nativeElement;\n            /** @type {?} */\n            var dir = this._getLayoutDirection();\n            if (dir == 'ltr') {\n                containerEl.scrollLeft = 0;\n            }\n            else {\n                containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n            }\n        }\n    };\n    /** The layout direction of the containing app. */\n    /**\n     * The layout direction of the containing app.\n     * @return {?}\n     */\n    MatTabHeader.prototype._getLayoutDirection = /**\n     * The layout direction of the containing app.\n     * @return {?}\n     */\n    function () {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    };\n    /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n    /**\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\n     * @return {?}\n     */\n    MatTabHeader.prototype._updateTabScrollPosition = /**\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var scrollDistance = this.scrollDistance;\n        /** @type {?} */\n        var translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n        // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n        // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n        // and ripples will exceed the boundaries of the visible tab bar.\n        // See: https://github.com/angular/material2/issues/10276\n        this._tabList.nativeElement.style.transform = \"translateX(\" + translateX + \"px)\";\n    };\n    Object.defineProperty(MatTabHeader.prototype, \"scrollDistance\", {\n        /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n        get: /**\n         * Sets the distance in pixels that the tab header should be transformed in the X-axis.\n         * @return {?}\n         */\n        function () { return this._scrollDistance; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\n            // Mark that the scroll distance has changed so that after the view is checked, the CSS\n            // transformation can move the header.\n            this._scrollDistanceChanged = true;\n            this._checkScrollingControls();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} scrollDir\n     * @return {?}\n     */\n    MatTabHeader.prototype._scrollHeader = /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} scrollDir\n     * @return {?}\n     */\n    function (scrollDir) {\n        /** @type {?} */\n        var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        // Move the scroll distance one-third the length of the tab list's viewport.\n        this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;\n    };\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} labelIndex\n     * @return {?}\n     */\n    MatTabHeader.prototype._scrollToLabel = /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} labelIndex\n     * @return {?}\n     */\n    function (labelIndex) {\n        /** @type {?} */\n        var selectedLabel = this._labelWrappers ? this._labelWrappers.toArray()[labelIndex] : null;\n        if (!selectedLabel) {\n            return;\n        }\n        /** @type {?} */\n        var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        /** @type {?} */\n        var labelBeforePos;\n        /** @type {?} */\n        var labelAfterPos;\n        if (this._getLayoutDirection() == 'ltr') {\n            labelBeforePos = selectedLabel.getOffsetLeft();\n            labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n        }\n        else {\n            labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n            labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n        }\n        /** @type {?} */\n        var beforeVisiblePos = this.scrollDistance;\n        /** @type {?} */\n        var afterVisiblePos = this.scrollDistance + viewLength;\n        if (labelBeforePos < beforeVisiblePos) {\n            // Scroll header to move label to the before direction\n            this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n        }\n        else if (labelAfterPos > afterVisiblePos) {\n            // Scroll header to move label to the after direction\n            this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n        }\n    };\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    MatTabHeader.prototype._checkPaginationEnabled = /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n        if (!isEnabled) {\n            this.scrollDistance = 0;\n        }\n        if (isEnabled !== this._showPaginationControls) {\n            this._changeDetectorRef.markForCheck();\n        }\n        this._showPaginationControls = isEnabled;\n    };\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    MatTabHeader.prototype._checkScrollingControls = /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    function () {\n        // Check if the pagination arrows should be activated.\n        this._disableScrollBefore = this.scrollDistance == 0;\n        this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    MatTabHeader.prototype._getMaxScrollDistance = /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n        /** @type {?} */\n        var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        return (lengthOfTabList - viewLength) || 0;\n    };\n    /** Tells the ink-bar to align itself to the current label wrapper */\n    /**\n     * Tells the ink-bar to align itself to the current label wrapper\n     * @return {?}\n     */\n    MatTabHeader.prototype._alignInkBarToSelectedTab = /**\n     * Tells the ink-bar to align itself to the current label wrapper\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length ?\n            this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement :\n            null;\n        this._inkBar.alignToElement(/** @type {?} */ ((selectedLabelWrapper)));\n    };\n    /** @nocollapse */\n    MatTabHeader.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: ChangeDetectorRef },\n        { type: ViewportRuler },\n        { type: Directionality, decorators: [{ type: Optional }] },\n        { type: NgZone }\n    ]; };\n    MatTabHeader.propDecorators = {\n        _labelWrappers: [{ type: ContentChildren, args: [MatTabLabelWrapper,] }],\n        _inkBar: [{ type: ViewChild, args: [MatInkBar,] }],\n        _tabListContainer: [{ type: ViewChild, args: ['tabListContainer',] }],\n        _tabList: [{ type: ViewChild, args: ['tabList',] }],\n        selectedIndex: [{ type: Input }],\n        selectFocusedIndex: [{ type: Output }],\n        indexFocused: [{ type: Output }]\n    };\nMatTabHeader.ngComponentDef = ɵngcc0.ɵdefineComponent({ type: MatTabHeader, selectors: [[\"mat-tab-header\"]], factory: function MatTabHeader_Factory(t) { return new (t || MatTabHeader)(ɵngcc0.ɵdirectiveInject(ElementRef), ɵngcc0.ɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵdirectiveInject(ViewportRuler), ɵngcc0.ɵdirectiveInject(Directionality, 8), ɵngcc0.ɵdirectiveInject(NgZone)); }, contentQueries: function MatTabHeader_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵcontentQuery(dirIndex, MatTabLabelWrapper, false, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadContentQuery()) && (ctx._labelWrappers = _t));\r\n    } }, viewQuery: function MatTabHeader_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵviewQuery(MatInkBar, true, null);\r\n        ɵngcc0.ɵviewQuery(_c7, true, null);\r\n        ɵngcc0.ɵviewQuery(_c8, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadViewQuery()) && (ctx._inkBar = _t.first));\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadViewQuery()) && (ctx._tabListContainer = _t.first));\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadViewQuery()) && (ctx._tabList = _t.first));\r\n    } }, hostBindings: function MatTabHeader_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c9);\r\n        ɵngcc0.ɵelementHostStyling(_c10);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵelementHostClassProp(0, ctx._showPaginationControls);\r\n        ɵngcc0.ɵelementHostClassProp(1, (ctx._getLayoutDirection() == \"rtl\"));\r\n        ɵngcc0.ɵelementHostStylingApply();\r\n    } }, inputs: { disableRipple: \"disableRipple\", selectedIndex: \"selectedIndex\" }, outputs: { selectFocusedIndex: \"selectFocusedIndex\", indexFocused: \"indexFocused\" }, features: [ɵngcc0.ɵInheritDefinitionFeature], ngContentSelectors: _c1, consts: 11, vars: 2, template: function MatTabHeader_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵprojectionDef();\r\n        ɵngcc0.ɵelementStart(0, \"div\", _c11);\r\n        ɵngcc0.ɵelementStyling(_c19);\r\n        ɵngcc0.ɵlistener(\"click\", function MatTabHeader_Template_div_click_0_listener($event) { return ctx._scrollHeader(\"before\"); });\r\n        ɵngcc0.ɵelement(1, \"div\", _c12);\r\n        ɵngcc0.ɵelementEnd();\r\n        ɵngcc0.ɵelementStart(2, \"div\", _c13, _c14);\r\n        ɵngcc0.ɵlistener(\"keydown\", function MatTabHeader_Template_div_keydown_2_listener($event) { return ctx._handleKeydown($event); });\r\n        ɵngcc0.ɵelementStart(4, \"div\", _c15, _c16);\r\n        ɵngcc0.ɵlistener(\"cdkObserveContent\", function MatTabHeader_Template_div_cdkObserveContent_4_listener($event) { return ctx._onContentChanges(); });\r\n        ɵngcc0.ɵelementStart(6, \"div\", _c17);\r\n        ɵngcc0.ɵprojection(7);\r\n        ɵngcc0.ɵelementEnd();\r\n        ɵngcc0.ɵelement(8, \"mat-ink-bar\");\r\n        ɵngcc0.ɵelementEnd();\r\n        ɵngcc0.ɵelementEnd();\r\n        ɵngcc0.ɵelementStart(9, \"div\", _c18);\r\n        ɵngcc0.ɵelementStyling(_c19);\r\n        ɵngcc0.ɵlistener(\"click\", function MatTabHeader_Template_div_click_9_listener($event) { return ctx._scrollHeader(\"after\"); });\r\n        ɵngcc0.ɵelement(10, \"div\", _c12);\r\n        ɵngcc0.ɵelementEnd();\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵelementClassProp(0, 0, ctx._disableScrollBefore);\r\n        ɵngcc0.ɵelementStylingApply(0);\r\n        ɵngcc0.ɵselect(0);\r\n        ɵngcc0.ɵelementProperty(0, \"matRippleDisabled\", ɵngcc0.ɵbind((ctx._disableScrollBefore || ctx.disableRipple)));\r\n        ɵngcc0.ɵelementClassProp(9, 0, ctx._disableScrollAfter);\r\n        ɵngcc0.ɵelementStylingApply(9);\r\n        ɵngcc0.ɵselect(9);\r\n        ɵngcc0.ɵelementProperty(9, \"matRippleDisabled\", ɵngcc0.ɵbind((ctx._disableScrollAfter || ctx.disableRipple)));\r\n    } }, directives: [ɵngcc1.MatRipple, ɵngcc2.CdkObserveContent, MatInkBar], styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}\"], encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabHeader, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-tab-header',\r\n                template: \"<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\" aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollBefore || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollBefore\\\" (click)=\\\"_scrollHeader('before')\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div><div class=\\\"mat-tab-label-container\\\" #tabListContainer (keydown)=\\\"_handleKeydown($event)\\\"><div class=\\\"mat-tab-list\\\" #tabList role=\\\"tablist\\\" (cdkObserveContent)=\\\"_onContentChanges()\\\"><div class=\\\"mat-tab-labels\\\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\" aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollAfter || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollAfter\\\" (click)=\\\"_scrollHeader('after')\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div>\",\r\n                styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}\"],\r\n                inputs: ['disableRipple'],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                host: {\r\n                    'class': 'mat-tab-header',\r\n                    '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\r\n                    '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\"\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: ChangeDetectorRef }, { type: ViewportRuler }, { type: Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: NgZone }]; }, { selectedIndex: [{\r\n            type: Input\r\n        }], selectedIndex: [], ngAfterContentChecked: [], _tabLabelCount: [], _selectedIndexChanged: [], _scrollDistanceChanged: [], _handleKeydown: [], ngAfterContentInit: [], _keyManager: [], ngOnDestroy: [], _onContentChanges: [], _updatePagination: [], focusIndex: [], focusIndex: [], _isValidIndex: [], _setTabFocus: [], _getLayoutDirection: [], _updateTabScrollPosition: [], scrollDistance: [], scrollDistance: [], _scrollHeader: [], _scrollToLabel: [], _checkPaginationEnabled: [], _showPaginationControls: [], _checkScrollingControls: [], _disableScrollBefore: [], _disableScrollAfter: [], _getMaxScrollDistance: [], _alignInkBarToSelectedTab: [], _labelWrappers: [{\r\n            type: ContentChildren,\r\n            args: [MatTabLabelWrapper]\r\n        }], _inkBar: [{\r\n            type: ViewChild,\r\n            args: [MatInkBar]\r\n        }], _tabListContainer: [{\r\n            type: ViewChild,\r\n            args: ['tabListContainer']\r\n        }], _tabList: [{\r\n            type: ViewChild,\r\n            args: ['tabList']\r\n        }], selectFocusedIndex: [{\r\n            type: Output\r\n        }], indexFocused: [{\r\n            type: Output\r\n        }] });\n    return MatTabHeader;\n}(_MatTabHeaderMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Used to generate unique ID's for each tab component\n  @type {?} */\nvar nextId = 0;\n/**\n * A simple change event emitted on focus or selection changes.\n */\nvar  /**\n * A simple change event emitted on focus or selection changes.\n */\nMatTabChangeEvent = /** @class */ (function () {\n    function MatTabChangeEvent() {\n    }\n    return MatTabChangeEvent;\n}());\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabGroupBase = /** @class */ (function () {\n    function MatTabGroupBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatTabGroupBase;\n}());\n/** @type {?} */\nvar _MatTabGroupMixinBase = mixinColor(mixinDisableRipple(MatTabGroupBase), 'primary');\n/**\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\n * animated ink-bar, keyboard navigation, and screen reader.\n * See: https://material.io/design/components/tabs.html\n */\nvar MatTabGroup = /** @class */ (function (_super) {\n    __extends(MatTabGroup, _super);\n    function MatTabGroup(elementRef, _changeDetectorRef) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._changeDetectorRef = _changeDetectorRef;\n        /**\n         * The tab index that should be selected after the content has been checked.\n         */\n        _this._indexToSelect = 0;\n        /**\n         * Snapshot of the height of the tab body wrapper before another tab is activated.\n         */\n        _this._tabBodyWrapperHeight = 0;\n        /**\n         * Subscription to tabs being added/removed.\n         */\n        _this._tabsSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to changes in the tab labels.\n         */\n        _this._tabLabelSubscription = Subscription.EMPTY;\n        _this._dynamicHeight = false;\n        _this._selectedIndex = null;\n        /**\n         * Position of the tab header.\n         */\n        _this.headerPosition = 'above';\n        /**\n         * Output to enable support for two-way binding on `[(selectedIndex)]`\n         */\n        _this.selectedIndexChange = new EventEmitter();\n        /**\n         * Event emitted when focus has changed within a tab group.\n         */\n        _this.focusChange = new EventEmitter();\n        /**\n         * Event emitted when the body animation has completed\n         */\n        _this.animationDone = new EventEmitter();\n        /**\n         * Event emitted when the tab selection has changed.\n         */\n        _this.selectedTabChange = new EventEmitter(true);\n        _this._groupId = nextId++;\n        return _this;\n    }\n    Object.defineProperty(MatTabGroup.prototype, \"dynamicHeight\", {\n        /** Whether the tab group should grow to the size of the active tab. */\n        get: /**\n         * Whether the tab group should grow to the size of the active tab.\n         * @return {?}\n         */\n        function () { return this._dynamicHeight; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._dynamicHeight = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"selectedIndex\", {\n        /** The index of the active tab. */\n        get: /**\n         * The index of the active tab.\n         * @return {?}\n         */\n        function () { return this._selectedIndex; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._indexToSelect = coerceNumberProperty(value, null);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"backgroundColor\", {\n        /** Background color of the tab group. */\n        get: /**\n         * Background color of the tab group.\n         * @return {?}\n         */\n        function () { return this._backgroundColor; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            /** @type {?} */\n            var nativeElement = this._elementRef.nativeElement;\n            nativeElement.classList.remove(\"mat-background-\" + this.backgroundColor);\n            if (value) {\n                nativeElement.classList.add(\"mat-background-\" + value);\n            }\n            this._backgroundColor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     */\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     * @return {?}\n     */\n    MatTabGroup.prototype.ngAfterContentChecked = /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\n        // If there is a change in selected index, emit a change event. Should not trigger if\n        // the selected index has not yet been initialized.\n        if (this._selectedIndex != indexToSelect) {\n            /** @type {?} */\n            var isFirstRun_1 = this._selectedIndex == null;\n            if (!isFirstRun_1) {\n                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n            }\n            // Changing these values after change detection has run\n            // since the checked content may contain references to them.\n            Promise.resolve().then(function () {\n                _this._tabs.forEach(function (tab, index) { return tab.isActive = index === indexToSelect; });\n                if (!isFirstRun_1) {\n                    _this.selectedIndexChange.emit(indexToSelect);\n                }\n            });\n        }\n        // Setup the position for each tab and optionally setup an origin on the next selected tab.\n        this._tabs.forEach(function (tab, index) {\n            tab.position = index - indexToSelect;\n            // If there is already a selected tab, then set up an origin for the next selected tab\n            // if it doesn't have one already.\n            if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n                tab.origin = indexToSelect - _this._selectedIndex;\n            }\n        });\n        if (this._selectedIndex !== indexToSelect) {\n            this._selectedIndex = indexToSelect;\n            this._changeDetectorRef.markForCheck();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTabGroup.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._subscribeToTabLabels();\n        // Subscribe to changes in the amount of tabs, in order to be\n        // able to re-render the content as new tabs are added or removed.\n        this._tabsSubscription = this._tabs.changes.subscribe(function () {\n            /** @type {?} */\n            var indexToSelect = _this._clampTabIndex(_this._indexToSelect);\n            // Maintain the previously-selected tab if a new tab is added or removed and there is no\n            // explicit change that selects a different tab.\n            if (indexToSelect === _this._selectedIndex) {\n                /** @type {?} */\n                var tabs = _this._tabs.toArray();\n                for (var i = 0; i < tabs.length; i++) {\n                    if (tabs[i].isActive) {\n                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n                        // adding a tab within the `selectedIndexChange` event.\n                        _this._indexToSelect = _this._selectedIndex = i;\n                        break;\n                    }\n                }\n            }\n            _this._subscribeToTabLabels();\n            _this._changeDetectorRef.markForCheck();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatTabGroup.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._tabsSubscription.unsubscribe();\n        this._tabLabelSubscription.unsubscribe();\n    };\n    /** Re-aligns the ink bar to the selected tab element. */\n    /**\n     * Re-aligns the ink bar to the selected tab element.\n     * @return {?}\n     */\n    MatTabGroup.prototype.realignInkBar = /**\n     * Re-aligns the ink bar to the selected tab element.\n     * @return {?}\n     */\n    function () {\n        if (this._tabHeader) {\n            this._tabHeader._alignInkBarToSelectedTab();\n        }\n    };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._focusChanged = /**\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        this.focusChange.emit(this._createChangeEvent(index));\n    };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._createChangeEvent = /**\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        /** @type {?} */\n        var event = new MatTabChangeEvent;\n        event.index = index;\n        if (this._tabs && this._tabs.length) {\n            event.tab = this._tabs.toArray()[index];\n        }\n        return event;\n    };\n    /**\n     * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     * @return {?}\n     */\n    MatTabGroup.prototype._subscribeToTabLabels = /**\n     * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._tabLabelSubscription) {\n            this._tabLabelSubscription.unsubscribe();\n        }\n        this._tabLabelSubscription = merge.apply(void 0, this._tabs.map(function (tab) { return tab._stateChanges; })).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });\n    };\n    /**\n     * Clamps the given index to the bounds of 0 and the tabs length.\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._clampTabIndex = /**\n     * Clamps the given index to the bounds of 0 and the tabs length.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        // Note the `|| 0`, which ensures that values like NaN can't get through\n        // and which would otherwise throw the component into an infinite loop\n        // (since Math.max(NaN, 0) === NaN).\n        return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n    };\n    /** Returns a unique id for each tab label element */\n    /**\n     * Returns a unique id for each tab label element\n     * @param {?} i\n     * @return {?}\n     */\n    MatTabGroup.prototype._getTabLabelId = /**\n     * Returns a unique id for each tab label element\n     * @param {?} i\n     * @return {?}\n     */\n    function (i) {\n        return \"mat-tab-label-\" + this._groupId + \"-\" + i;\n    };\n    /** Returns a unique id for each tab content element */\n    /**\n     * Returns a unique id for each tab content element\n     * @param {?} i\n     * @return {?}\n     */\n    MatTabGroup.prototype._getTabContentId = /**\n     * Returns a unique id for each tab content element\n     * @param {?} i\n     * @return {?}\n     */\n    function (i) {\n        return \"mat-tab-content-\" + this._groupId + \"-\" + i;\n    };\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     */\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     * @param {?} tabHeight\n     * @return {?}\n     */\n    MatTabGroup.prototype._setTabBodyWrapperHeight = /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     * @param {?} tabHeight\n     * @return {?}\n     */\n    function (tabHeight) {\n        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n            return;\n        }\n        /** @type {?} */\n        var wrapper = this._tabBodyWrapper.nativeElement;\n        wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n        // This conditional forces the browser to paint the height so that\n        // the animation to the new height can have an origin.\n        if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n            wrapper.style.height = tabHeight + 'px';\n        }\n    };\n    /** Removes the height of the tab body wrapper. */\n    /**\n     * Removes the height of the tab body wrapper.\n     * @return {?}\n     */\n    MatTabGroup.prototype._removeTabBodyWrapperHeight = /**\n     * Removes the height of the tab body wrapper.\n     * @return {?}\n     */\n    function () {\n        this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;\n        this._tabBodyWrapper.nativeElement.style.height = '';\n        this.animationDone.emit();\n    };\n    /** Handle click events, setting new selected index if appropriate. */\n    /**\n     * Handle click events, setting new selected index if appropriate.\n     * @param {?} tab\n     * @param {?} tabHeader\n     * @param {?} idx\n     * @return {?}\n     */\n    MatTabGroup.prototype._handleClick = /**\n     * Handle click events, setting new selected index if appropriate.\n     * @param {?} tab\n     * @param {?} tabHeader\n     * @param {?} idx\n     * @return {?}\n     */\n    function (tab, tabHeader, idx) {\n        if (!tab.disabled) {\n            this.selectedIndex = tabHeader.focusIndex = idx;\n        }\n    };\n    /** Retrieves the tabindex for the tab. */\n    /**\n     * Retrieves the tabindex for the tab.\n     * @param {?} tab\n     * @param {?} idx\n     * @return {?}\n     */\n    MatTabGroup.prototype._getTabIndex = /**\n     * Retrieves the tabindex for the tab.\n     * @param {?} tab\n     * @param {?} idx\n     * @return {?}\n     */\n    function (tab, idx) {\n        if (tab.disabled) {\n            return null;\n        }\n        return this.selectedIndex === idx ? 0 : -1;\n    };\n    /** @nocollapse */\n    MatTabGroup.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: ChangeDetectorRef }\n    ]; };\n    MatTabGroup.propDecorators = {\n        _tabs: [{ type: ContentChildren, args: [MatTab,] }],\n        _tabBodyWrapper: [{ type: ViewChild, args: ['tabBodyWrapper',] }],\n        _tabHeader: [{ type: ViewChild, args: ['tabHeader',] }],\n        dynamicHeight: [{ type: Input }],\n        selectedIndex: [{ type: Input }],\n        headerPosition: [{ type: Input }],\n        backgroundColor: [{ type: Input }],\n        selectedIndexChange: [{ type: Output }],\n        focusChange: [{ type: Output }],\n        animationDone: [{ type: Output }],\n        selectedTabChange: [{ type: Output }]\n    };\nMatTabGroup.ngComponentDef = ɵngcc0.ɵdefineComponent({ type: MatTabGroup, selectors: [[\"mat-tab-group\"]], factory: function MatTabGroup_Factory(t) { return new (t || MatTabGroup)(ɵngcc0.ɵdirectiveInject(ElementRef), ɵngcc0.ɵdirectiveInject(ChangeDetectorRef)); }, contentQueries: function MatTabGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵcontentQuery(dirIndex, MatTab, false, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadContentQuery()) && (ctx._tabs = _t));\r\n    } }, viewQuery: function MatTabGroup_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵviewQuery(_c20, true, null);\r\n        ɵngcc0.ɵviewQuery(_c21, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadViewQuery()) && (ctx._tabBodyWrapper = _t.first));\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadViewQuery()) && (ctx._tabHeader = _t.first));\r\n    } }, hostBindings: function MatTabGroup_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c22);\r\n        ɵngcc0.ɵelementHostStyling(_c23);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵelementHostClassProp(0, ctx.dynamicHeight);\r\n        ɵngcc0.ɵelementHostClassProp(1, (ctx.headerPosition === \"below\"));\r\n        ɵngcc0.ɵelementHostStylingApply();\r\n    } }, inputs: { color: \"color\", disableRipple: \"disableRipple\", dynamicHeight: \"dynamicHeight\", selectedIndex: \"selectedIndex\", backgroundColor: \"backgroundColor\", headerPosition: \"headerPosition\" }, outputs: { selectedIndexChange: \"selectedIndexChange\", focusChange: \"focusChange\", animationDone: \"animationDone\", selectedTabChange: \"selectedTabChange\" }, exportAs: [\"matTabGroup\"], features: [ɵngcc0.ɵInheritDefinitionFeature], consts: 6, vars: 4, template: function MatTabGroup_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵelementStart(0, \"mat-tab-header\", _c24, _c25);\r\n        ɵngcc0.ɵlistener(\"indexFocused\", function MatTabGroup_Template_mat_tab_header_indexFocused_0_listener($event) { return ctx._focusChanged($event); });\r\n        ɵngcc0.ɵlistener(\"selectFocusedIndex\", function MatTabGroup_Template_mat_tab_header_selectFocusedIndex_0_listener($event) { return ctx.selectedIndex = $event; });\r\n        ɵngcc0.ɵtemplate(2, MatTabGroup_div_2_Template, 4, 12, \"div\", _c26);\r\n        ɵngcc0.ɵelementEnd();\r\n        ɵngcc0.ɵelementStart(3, \"div\", _c27, _c28);\r\n        ɵngcc0.ɵtemplate(5, MatTabGroup_mat_tab_body_5_Template, 1, 5, \"mat-tab-body\", _c29);\r\n        ɵngcc0.ɵelementEnd();\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵselect(0);\r\n        ɵngcc0.ɵelementProperty(0, \"selectedIndex\", ɵngcc0.ɵbind(ctx.selectedIndex));\r\n        ɵngcc0.ɵelementProperty(0, \"disableRipple\", ɵngcc0.ɵbind(ctx.disableRipple));\r\n        ɵngcc0.ɵselect(2);\r\n        ɵngcc0.ɵelementProperty(2, \"ngForOf\", ɵngcc0.ɵbind(ctx._tabs));\r\n        ɵngcc0.ɵselect(5);\r\n        ɵngcc0.ɵelementProperty(5, \"ngForOf\", ɵngcc0.ɵbind(ctx._tabs));\r\n    } }, directives: [MatTabHeader,\r\n        MatTabLabelWrapper, ɵngcc1.MatRipple, ɵngcc3.CdkMonitorFocus, ɵngcc4.NgForOf, ɵngcc4.NgIf, ɵngcc5.CdkPortalOutlet, MatTabBody], styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\"], encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabGroup, [{\r\n        type: Component,\r\n        args: [{ selector: 'mat-tab-group',\r\n                exportAs: 'matTabGroup',\r\n                template: \"<mat-tab-header #tabHeader [selectedIndex]=\\\"selectedIndex\\\" [disableRipple]=\\\"disableRipple\\\" (indexFocused)=\\\"_focusChanged($event)\\\" (selectFocusedIndex)=\\\"selectedIndex = $event\\\"><div class=\\\"mat-tab-label\\\" role=\\\"tab\\\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabLabelId(i)\\\" [attr.tabIndex]=\\\"_getTabIndex(tab, i)\\\" [attr.aria-posinset]=\\\"i + 1\\\" [attr.aria-setsize]=\\\"_tabs.length\\\" [attr.aria-controls]=\\\"_getTabContentId(i)\\\" [attr.aria-selected]=\\\"selectedIndex == i\\\" [attr.aria-label]=\\\"tab.ariaLabel || null\\\" [attr.aria-labelledby]=\\\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\\\" [class.mat-tab-label-active]=\\\"selectedIndex == i\\\" [disabled]=\\\"tab.disabled\\\" [matRippleDisabled]=\\\"tab.disabled || disableRipple\\\" (click)=\\\"_handleClick(tab, tabHeader, i)\\\"><div class=\\\"mat-tab-label-content\\\"><ng-template [ngIf]=\\\"tab.templateLabel\\\"><ng-template [cdkPortalOutlet]=\\\"tab.templateLabel\\\"></ng-template></ng-template><ng-template [ngIf]=\\\"!tab.templateLabel\\\">{{tab.textLabel}}</ng-template></div></div></mat-tab-header><div class=\\\"mat-tab-body-wrapper\\\" #tabBodyWrapper><mat-tab-body role=\\\"tabpanel\\\" *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabContentId(i)\\\" [attr.aria-labelledby]=\\\"_getTabLabelId(i)\\\" [class.mat-tab-body-active]=\\\"selectedIndex == i\\\" [content]=\\\"tab.content\\\" [position]=\\\"tab.position\\\" [origin]=\\\"tab.origin\\\" (_onCentered)=\\\"_removeTabBodyWrapperHeight()\\\" (_onCentering)=\\\"_setTabBodyWrapperHeight($event)\\\"></mat-tab-body></div>\",\r\n                styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\"],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                inputs: ['color', 'disableRipple'],\r\n                host: {\r\n                    'class': 'mat-tab-group',\r\n                    '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',\r\n                    '[class.mat-tab-group-inverted-header]': 'headerPosition === \"below\"'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: ChangeDetectorRef }]; }, { dynamicHeight: [{\r\n            type: Input\r\n        }], dynamicHeight: [], selectedIndex: [{\r\n            type: Input\r\n        }], selectedIndex: [], backgroundColor: [{\r\n            type: Input\r\n        }], backgroundColor: [], ngAfterContentChecked: [], _indexToSelect: [], _selectedIndex: [], ngAfterContentInit: [], _tabsSubscription: [], ngOnDestroy: [], realignInkBar: [], _focusChanged: [], _createChangeEvent: [], _subscribeToTabLabels: [], _tabLabelSubscription: [], _clampTabIndex: [], _getTabLabelId: [], _getTabContentId: [], _setTabBodyWrapperHeight: [], _removeTabBodyWrapperHeight: [], _tabBodyWrapperHeight: [], _handleClick: [], _getTabIndex: [], _tabs: [{\r\n            type: ContentChildren,\r\n            args: [MatTab]\r\n        }], _tabBodyWrapper: [{\r\n            type: ViewChild,\r\n            args: ['tabBodyWrapper']\r\n        }], _tabHeader: [{\r\n            type: ViewChild,\r\n            args: ['tabHeader']\r\n        }], headerPosition: [{\r\n            type: Input\r\n        }], selectedIndexChange: [{\r\n            type: Output\r\n        }], focusChange: [{\r\n            type: Output\r\n        }], animationDone: [{\r\n            type: Output\r\n        }], selectedTabChange: [{\r\n            type: Output\r\n        }] });\n    return MatTabGroup;\n}(_MatTabGroupMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatTabNavBase = /** @class */ (function () {\n    function MatTabNavBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatTabNavBase;\n}());\n/** @type {?} */\nvar _MatTabNavMixinBase = mixinDisableRipple(mixinColor(MatTabNavBase, 'primary'));\n/**\n * Navigation component matching the styles of the tab group header.\n * Provides anchored navigation with animated ink bar.\n */\nvar MatTabNav = /** @class */ (function (_super) {\n    __extends(MatTabNav, _super);\n    function MatTabNav(elementRef, _dir, _ngZone, _changeDetectorRef, _viewportRuler) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._dir = _dir;\n        _this._ngZone = _ngZone;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._viewportRuler = _viewportRuler;\n        /**\n         * Subject that emits when the component has been destroyed.\n         */\n        _this._onDestroy = new Subject();\n        return _this;\n    }\n    Object.defineProperty(MatTabNav.prototype, \"backgroundColor\", {\n        /** Background color of the tab nav. */\n        get: /**\n         * Background color of the tab nav.\n         * @return {?}\n         */\n        function () { return this._backgroundColor; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            /** @type {?} */\n            var nativeElement = this._elementRef.nativeElement;\n            nativeElement.classList.remove(\"mat-background-\" + this.backgroundColor);\n            if (value) {\n                nativeElement.classList.add(\"mat-background-\" + value);\n            }\n            this._backgroundColor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Notifies the component that the active link has been changed.\n     * @breaking-change 8.0.0 `element` parameter to be removed.\n     */\n    /**\n     * Notifies the component that the active link has been changed.\n     * \\@breaking-change 8.0.0 `element` parameter to be removed.\n     * @param {?} element\n     * @return {?}\n     */\n    MatTabNav.prototype.updateActiveLink = /**\n     * Notifies the component that the active link has been changed.\n     * \\@breaking-change 8.0.0 `element` parameter to be removed.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Note: keeping the `element` for backwards-compat, but isn't being used for anything.\n        // @breaking-change 8.0.0\n        this._activeLinkChanged = !!element;\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * @return {?}\n     */\n    MatTabNav.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */\n            var dirChange = _this._dir ? _this._dir.change : of(null);\n            return merge(dirChange, _this._viewportRuler.change(10))\n                .pipe(takeUntil(_this._onDestroy))\n                .subscribe(function () { return _this._alignInkBar(); });\n        });\n    };\n    /** Checks if the active link has been changed and, if so, will update the ink bar. */\n    /**\n     * Checks if the active link has been changed and, if so, will update the ink bar.\n     * @return {?}\n     */\n    MatTabNav.prototype.ngAfterContentChecked = /**\n     * Checks if the active link has been changed and, if so, will update the ink bar.\n     * @return {?}\n     */\n    function () {\n        if (this._activeLinkChanged) {\n            /** @type {?} */\n            var activeTab = this._tabLinks.find(function (tab) { return tab.active; });\n            this._activeLinkElement = activeTab ? activeTab._elementRef : null;\n            this._alignInkBar();\n            this._activeLinkChanged = false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTabNav.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._onDestroy.next();\n        this._onDestroy.complete();\n    };\n    /** Aligns the ink bar to the active link. */\n    /**\n     * Aligns the ink bar to the active link.\n     * @return {?}\n     */\n    MatTabNav.prototype._alignInkBar = /**\n     * Aligns the ink bar to the active link.\n     * @return {?}\n     */\n    function () {\n        if (this._activeLinkElement) {\n            this._inkBar.show();\n            this._inkBar.alignToElement(this._activeLinkElement.nativeElement);\n        }\n        else {\n            this._inkBar.hide();\n        }\n    };\n    /** @nocollapse */\n    MatTabNav.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Directionality, decorators: [{ type: Optional }] },\n        { type: NgZone },\n        { type: ChangeDetectorRef },\n        { type: ViewportRuler }\n    ]; };\n    MatTabNav.propDecorators = {\n        _inkBar: [{ type: ViewChild, args: [MatInkBar,] }],\n        _tabLinks: [{ type: ContentChildren, args: [forwardRef(function () { return MatTabLink; }), { descendants: true },] }],\n        backgroundColor: [{ type: Input }]\n    };\nMatTabNav.ngComponentDef = ɵngcc0.ɵdefineComponent({ type: MatTabNav, selectors: [[\"\", \"mat-tab-nav-bar\", \"\"]], factory: function MatTabNav_Factory(t) { return new (t || MatTabNav)(ɵngcc0.ɵdirectiveInject(ElementRef), ɵngcc0.ɵdirectiveInject(Directionality, 8), ɵngcc0.ɵdirectiveInject(NgZone), ɵngcc0.ɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵdirectiveInject(ViewportRuler)); }, contentQueries: function MatTabNav_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵcontentQuery(dirIndex, MatTabLink, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadContentQuery()) && (ctx._tabLinks = _t));\r\n    } }, viewQuery: function MatTabNav_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵviewQuery(MatInkBar, true, null);\r\n    } if (rf & 2) {\r\n        var _t;\r\n        (ɵngcc0.ɵqueryRefresh(_t = ɵngcc0.ɵloadViewQuery()) && (ctx._inkBar = _t.first));\r\n    } }, hostBindings: function MatTabNav_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵelementHostAttrs(_c37);\r\n    } }, inputs: { color: \"color\", disableRipple: \"disableRipple\", backgroundColor: \"backgroundColor\" }, exportAs: [\"matTabNavBar\", \"matTabNav\"], features: [ɵngcc0.ɵInheritDefinitionFeature], attrs: _c38, ngContentSelectors: _c1, consts: 3, vars: 0, template: function MatTabNav_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵprojectionDef();\r\n        ɵngcc0.ɵelementStart(0, \"div\", _c39);\r\n        ɵngcc0.ɵlistener(\"cdkObserveContent\", function MatTabNav_Template_div_cdkObserveContent_0_listener($event) { return ctx._alignInkBar(); });\r\n        ɵngcc0.ɵprojection(1);\r\n        ɵngcc0.ɵelement(2, \"mat-ink-bar\");\r\n        ɵngcc0.ɵelementEnd();\r\n    } }, directives: [ɵngcc2.CdkObserveContent, MatInkBar], styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative;display:flex}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}\"], encapsulation: 2, changeDetection: 0 });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabNav, [{\r\n        type: Component,\r\n        args: [{ selector: '[mat-tab-nav-bar]',\r\n                exportAs: 'matTabNavBar, matTabNav',\r\n                inputs: ['color', 'disableRipple'],\r\n                template: \"<div class=\\\"mat-tab-links\\\" (cdkObserveContent)=\\\"_alignInkBar()\\\"><ng-content></ng-content><mat-ink-bar></mat-ink-bar></div>\",\r\n                styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative;display:flex}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}\"],\r\n                host: { 'class': 'mat-tab-nav-bar' },\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush\r\n            }]\r\n    }], function () { return [{ type: ElementRef }, { type: Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: NgZone }, { type: ChangeDetectorRef }, { type: ViewportRuler }]; }, { backgroundColor: [{\r\n            type: Input\r\n        }], backgroundColor: [], updateActiveLink: [], _activeLinkChanged: [], ngAfterContentInit: [], ngAfterContentChecked: [], _activeLinkElement: [], ngOnDestroy: [], _alignInkBar: [], _inkBar: [{\r\n            type: ViewChild,\r\n            args: [MatInkBar]\r\n        }], _tabLinks: [{\r\n            type: ContentChildren,\r\n            args: [forwardRef(function () { return MatTabLink; }), { descendants: true }]\r\n        }] });\n    return MatTabNav;\n}(_MatTabNavMixinBase));\nvar MatTabLinkBase = /** @class */ (function () {\n    function MatTabLinkBase() {\n    }\n    return MatTabLinkBase;\n}());\n/** @type {?} */\nvar _MatTabLinkMixinBase = mixinTabIndex(mixinDisableRipple(mixinDisabled(MatTabLinkBase)));\n/**\n * Link inside of a `mat-tab-nav-bar`.\n */\nvar MatTabLink = /** @class */ (function (_super) {\n    __extends(MatTabLink, _super);\n    function MatTabLink(_tabNavBar, _elementRef, ngZone, platform, globalOptions, tabIndex, _focusMonitor) {\n        var _this = _super.call(this) || this;\n        _this._tabNavBar = _tabNavBar;\n        _this._elementRef = _elementRef;\n        _this._focusMonitor = _focusMonitor;\n        /**\n         * Whether the tab link is active or not.\n         */\n        _this._isActive = false;\n        /**\n         * Whether the ripples are globally disabled through the RippleGlobalOptions\n         */\n        _this._ripplesGloballyDisabled = false;\n        /**\n         * Ripple configuration for ripples that are launched on pointer down.\n         * \\@docs-private\n         */\n        _this.rippleConfig = {};\n        _this._tabLinkRipple = new RippleRenderer(_this, ngZone, _elementRef, platform);\n        _this._tabLinkRipple.setupTriggerEvents(_elementRef.nativeElement);\n        _this.tabIndex = parseInt(tabIndex) || 0;\n        if (globalOptions) {\n            // TODO(paul): Do not copy each option manually. Allow dynamic global option changes: #9729\n            _this._ripplesGloballyDisabled = !!globalOptions.disabled;\n            _this.rippleConfig = {\n                terminateOnPointerUp: globalOptions.terminateOnPointerUp,\n                animation: globalOptions.animation,\n            };\n        }\n        if (_focusMonitor) {\n            _focusMonitor.monitor(_elementRef);\n        }\n        return _this;\n    }\n    Object.defineProperty(MatTabLink.prototype, \"active\", {\n        /** Whether the link is active. */\n        get: /**\n         * Whether the link is active.\n         * @return {?}\n         */\n        function () { return this._isActive; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (value !== this._isActive) {\n                this._isActive = value;\n                this._tabNavBar.updateActiveLink(this._elementRef);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabLink.prototype, \"rippleDisabled\", {\n        /**\n         * Whether ripples are disabled on interaction\n         * @docs-private\n         */\n        get: /**\n         * Whether ripples are disabled on interaction\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||\n                this._ripplesGloballyDisabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatTabLink.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._tabLinkRipple._removeTriggerEvents();\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n    };\n    /** @nocollapse */\n    MatTabLink.ctorParameters = function () { return [\n        { type: MatTabNav },\n        { type: ElementRef },\n        { type: NgZone },\n        { type: Platform },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n        { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },\n        { type: FocusMonitor }\n    ]; };\n    MatTabLink.propDecorators = {\n        active: [{ type: Input }]\n    };\nMatTabLink.ngDirectiveDef = ɵngcc0.ɵdefineDirective({ type: MatTabLink, selectors: [[\"\", \"mat-tab-link\", \"\"], [\"\", \"matTabLink\", \"\"]], factory: function MatTabLink_Factory(t) { return new (t || MatTabLink)(ɵngcc0.ɵdirectiveInject(MatTabNav), ɵngcc0.ɵdirectiveInject(ElementRef), ɵngcc0.ɵdirectiveInject(NgZone), ɵngcc0.ɵdirectiveInject(Platform), ɵngcc0.ɵdirectiveInject(MAT_RIPPLE_GLOBAL_OPTIONS, 8), ɵngcc0.ɵinjectAttribute('tabindex'), ɵngcc0.ɵdirectiveInject(FocusMonitor)); }, hostBindings: function MatTabLink_HostBindings(rf, ctx, elIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵallocHostVars(3);\r\n        ɵngcc0.ɵelementHostAttrs(_c40);\r\n        ɵngcc0.ɵelementHostStyling(_c41);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵelementAttribute(elIndex, \"aria-current\", ɵngcc0.ɵbind(ctx.active));\r\n        ɵngcc0.ɵelementAttribute(elIndex, \"aria-disabled\", ɵngcc0.ɵbind(ctx.disabled.toString()));\r\n        ɵngcc0.ɵelementAttribute(elIndex, \"tabIndex\", ɵngcc0.ɵbind(ctx.tabIndex));\r\n        ɵngcc0.ɵelementHostClassProp(0, ctx.disabled);\r\n        ɵngcc0.ɵelementHostClassProp(1, ctx.active);\r\n        ɵngcc0.ɵelementHostStylingApply();\r\n    } }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", tabIndex: \"tabIndex\", active: \"active\" }, exportAs: [\"matTabLink\"], features: [ɵngcc0.ɵInheritDefinitionFeature] });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabLink, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-tab-link], [matTabLink]',\r\n                exportAs: 'matTabLink',\r\n                inputs: ['disabled', 'disableRipple', 'tabIndex'],\r\n                host: {\r\n                    'class': 'mat-tab-link',\r\n                    '[attr.aria-current]': 'active',\r\n                    '[attr.aria-disabled]': 'disabled.toString()',\r\n                    '[attr.tabIndex]': 'tabIndex',\r\n                    '[class.mat-tab-disabled]': 'disabled',\r\n                    '[class.mat-tab-label-active]': 'active'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: MatTabNav }, { type: ElementRef }, { type: NgZone }, { type: Platform }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [MAT_RIPPLE_GLOBAL_OPTIONS]\r\n            }] }, { type: String, decorators: [{\r\n                type: Attribute,\r\n                args: ['tabindex']\r\n            }] }, { type: FocusMonitor }]; }, { active: [{\r\n            type: Input\r\n        }], active: [], rippleDisabled: [], ngOnDestroy: [] });\n    return MatTabLink;\n}(_MatTabLinkMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nvar MatTabsModule = /** @class */ (function () {\n    function MatTabsModule() {\n    }\nMatTabsModule.ngModuleDef = ɵngcc0.ɵdefineNgModule({ type: MatTabsModule });\n/*@__PURE__*/ ɵngcc0.ɵsetNgModuleScope(MatTabsModule, { declarations: function () { return [MatTabGroup,\r\n        MatTabLabel,\r\n        MatTab,\r\n        MatInkBar,\r\n        MatTabLabelWrapper,\r\n        MatTabNav,\r\n        MatTabLink,\r\n        MatTabBody,\r\n        MatTabBodyPortal,\r\n        MatTabHeader,\r\n        MatTabContent]; }, imports: function () { return [CommonModule,\r\n        MatCommonModule,\r\n        PortalModule,\r\n        MatRippleModule,\r\n        ObserversModule,\r\n        A11yModule]; }, exports: function () { return [MatCommonModule,\r\n        MatTabGroup,\r\n        MatTabLabel,\r\n        MatTab,\r\n        MatTabNav,\r\n        MatTabLink,\r\n        MatTabContent]; } });\n/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatTabsModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [\r\n                    CommonModule,\r\n                    MatCommonModule,\r\n                    PortalModule,\r\n                    MatRippleModule,\r\n                    ObserversModule,\r\n                    A11yModule,\r\n                ],\r\n                // Don't export all components because some are only to be used internally.\r\n                exports: [\r\n                    MatCommonModule,\r\n                    MatTabGroup,\r\n                    MatTabLabel,\r\n                    MatTab,\r\n                    MatTabNav,\r\n                    MatTabLink,\r\n                    MatTabContent,\r\n                ],\r\n                declarations: [\r\n                    MatTabGroup,\r\n                    MatTabLabel,\r\n                    MatTab,\r\n                    MatInkBar,\r\n                    MatTabLabelWrapper,\r\n                    MatTabNav,\r\n                    MatTabLink,\r\n                    MatTabBody,\r\n                    MatTabBodyPortal,\r\n                    MatTabHeader,\r\n                    MatTabContent,\r\n                ]\r\n            }]\r\n    }], function () { return []; }, null);\nMatTabsModule.ngInjectorDef = ɵngcc0.defineInjector({ factory: function MatTabsModule_Factory(t) { return new (t || MatTabsModule)(); }, imports: [[\r\n            CommonModule,\r\n            MatCommonModule,\r\n            PortalModule,\r\n            MatRippleModule,\r\n            ObserversModule,\r\n            A11yModule,\r\n        ],\r\n        MatCommonModule] });\n    return MatTabsModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { MatInkBar, _MAT_INK_BAR_POSITIONER, MatTabBody, MatTabBodyPortal, MatTabHeader, MatTabLabelWrapper, MatTab, MatTabLabel, MatTabNav, MatTabLink, MatTabContent, MatTabsModule, MatTabChangeEvent, MatTabGroupBase, _MatTabGroupMixinBase, MatTabGroup, matTabsAnimations, _MAT_INK_BAR_POSITIONER_FACTORY as ɵa23, MatTabBase as ɵf23, _MatTabMixinBase as ɵg23, MatTabHeaderBase as ɵb23, _MatTabHeaderMixinBase as ɵc23, MatTabLabelWrapperBase as ɵd23, _MatTabLabelWrapperMixinBase as ɵe23, MatTabLinkBase as ɵj23, MatTabNavBase as ɵh23, _MatTabLinkMixinBase as ɵk23, _MatTabNavMixinBase as ɵi23 };\n\n//# sourceMappingURL=tabs.es5.js.map","/* tslint:disable component-selector */\nimport { Component, ViewChild, Input, ViewChildren, QueryList } from '@angular/core';\nimport { CodeComponent } from './code.component';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/material\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"./code.component\";\nvar _c0 = [\"content\"];\nvar _c1 = [2, \"display\", \"none\"];\nvar _c2 = [\"content\", \"\"];\nvar _c3 = [\"disableRipple\", \"\", 1, \"code-tab-group\"];\nvar _c4 = [\"style\", \"overflow-y: hidden;\", 4, \"ngFor\", \"ngForOf\"];\nvar _c5 = [2, \"overflow-y\", \"hidden\"];\nvar _c6 = [\"mat-tab-label\", \"\"];\nvar _c7 = [3, \"language\", \"linenums\", \"path\", \"region\", \"header\"];\nfunction CodeTabsComponent_mat_tab_5_ng_template_1_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵelementStart(0, \"span\");\n    i0.ɵelementStyling();\n    i0.ɵtext(1);\n    i0.ɵelementEnd();\n} if (rf & 2) {\n    var tab_r90 = i0.ɵnextContext().$implicit;\n    i0.ɵelementStylingMap(0, i0.ɵinterpolation1(\"\", tab_r90.class, \"\"));\n    i0.ɵelementStylingApply(0);\n    i0.ɵselect(1);\n    i0.ɵtextBinding(1, i0.ɵinterpolation1(\"\", tab_r90.header, \"\"));\n} }\nfunction CodeTabsComponent_mat_tab_5_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵelementStart(0, \"mat-tab\", _c5);\n    i0.ɵtemplate(1, CodeTabsComponent_mat_tab_5_ng_template_1_Template, 2, 2, \"ng-template\", _c6);\n    i0.ɵelementStart(2, \"aio-code\", _c7);\n    i0.ɵelementStyling();\n    i0.ɵelementEnd();\n    i0.ɵelementEnd();\n} if (rf & 2) {\n    var tab_r90 = ctx.$implicit;\n    i0.ɵelementStylingMap(2, i0.ɵinterpolation1(\"\", tab_r90.class, \"\"));\n    i0.ɵelementStylingApply(2);\n    i0.ɵselect(2);\n    i0.ɵelementProperty(2, \"language\", i0.ɵbind(tab_r90.language));\n    i0.ɵelementProperty(2, \"linenums\", i0.ɵbind(tab_r90.linenums));\n    i0.ɵelementProperty(2, \"path\", i0.ɵbind(tab_r90.path));\n    i0.ɵelementProperty(2, \"region\", i0.ɵbind(tab_r90.region));\n    i0.ɵelementProperty(2, \"header\", i0.ɵbind(tab_r90.header));\n} }\nvar _c8 = [];\n/**\n * Renders a set of tab group of code snippets.\n *\n * The innerHTML of the `<code-tabs>` component should contain `<code-pane>` elements.\n * Each `<code-pane>` has the same interface as the embedded `<code-example>` component.\n * The optional `linenums` attribute is the default `linenums` for each code pane.\n */\nvar CodeTabsComponent = /** @class */ (function () {\n    function CodeTabsComponent() {\n    }\n    CodeTabsComponent.prototype.ngOnInit = function () {\n        this.tabs = [];\n        var codeExamples = this.content.nativeElement.querySelectorAll('code-pane');\n        for (var i = 0; i < codeExamples.length; i++) {\n            var tabContent = codeExamples[i];\n            this.tabs.push(this.getTabInfo(tabContent));\n        }\n    };\n    CodeTabsComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.codeComponents.toArray().forEach(function (codeComponent, i) {\n            codeComponent.code = _this.tabs[i].code;\n        });\n    };\n    /** Gets the extracted TabInfo data from the provided code-pane element. */\n    CodeTabsComponent.prototype.getTabInfo = function (tabContent) {\n        return {\n            class: tabContent.getAttribute('class'),\n            code: tabContent.innerHTML,\n            language: tabContent.getAttribute('language'),\n            linenums: tabContent.getAttribute('linenums') || this.linenums,\n            path: tabContent.getAttribute('path') || '',\n            region: tabContent.getAttribute('region') || '',\n            header: tabContent.getAttribute('header')\n        };\n    };\n    CodeTabsComponent.ngComponentDef = i0.ɵdefineComponent({ type: CodeTabsComponent, selectors: [[\"code-tabs\"]], factory: function CodeTabsComponent_Factory(t) { return new (t || CodeTabsComponent)(); }, viewQuery: function CodeTabsComponent_Query(rf, ctx) { if (rf & 1) {\n            i0.ɵviewQuery(_c0, true, null);\n            i0.ɵviewQuery(CodeComponent, true, null);\n        } if (rf & 2) {\n            var _t;\n            (i0.ɵqueryRefresh((_t = i0.ɵloadViewQuery())) && (ctx.content = _t.first));\n            (i0.ɵqueryRefresh((_t = i0.ɵloadViewQuery())) && (ctx.codeComponents = _t));\n        } }, inputs: { linenums: \"linenums\" }, ngContentSelectors: _c8, consts: 6, vars: 1, template: function CodeTabsComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵprojectionDef();\n            i0.ɵelementStart(0, \"div\", _c1, _c2);\n            i0.ɵprojection(2);\n            i0.ɵelementEnd();\n            i0.ɵelementStart(3, \"mat-card\");\n            i0.ɵelementStart(4, \"mat-tab-group\", _c3);\n            i0.ɵtemplate(5, CodeTabsComponent_mat_tab_5_Template, 3, 6, \"mat-tab\", _c4);\n            i0.ɵelementEnd();\n            i0.ɵelementEnd();\n        } if (rf & 2) {\n            i0.ɵselect(5);\n            i0.ɵelementProperty(5, \"ngForOf\", i0.ɵbind(ctx.tabs));\n        } }, directives: [i1.MatCard, i1.MatTabGroup, i2.NgForOf, i1.MatTab, i1.MatTabLabel, i3.CodeComponent], encapsulation: 2 });\n    return CodeTabsComponent;\n}());\nexport { CodeTabsComponent };\n/*@__PURE__*/ i0.ɵsetClassMetadata(CodeTabsComponent, [{\n        type: Component,\n        args: [{\n                selector: 'code-tabs',\n                template: \"\\n    <!-- Use content projection so that the provided HTML's code-panes can be split into tabs -->\\n    <div #content style=\\\"display: none\\\"><ng-content></ng-content></div>\\n\\n    <mat-card>\\n      <mat-tab-group class=\\\"code-tab-group\\\" disableRipple>\\n        <mat-tab style=\\\"overflow-y: hidden;\\\" *ngFor=\\\"let tab of tabs\\\">\\n          <ng-template mat-tab-label>\\n            <span class=\\\"{{ tab.class }}\\\">{{ tab.header }}</span>\\n          </ng-template>\\n          <aio-code class=\\\"{{ tab.class }}\\\"\\n                    [language]=\\\"tab.language\\\"\\n                    [linenums]=\\\"tab.linenums\\\"\\n                    [path]=\\\"tab.path\\\"\\n                    [region]=\\\"tab.region\\\"\\n                    [header]=\\\"tab.header\\\">\\n          </aio-code>\\n        </mat-tab>\\n      </mat-tab-group>\\n    </mat-card>\\n  \",\n            }]\n    }], null, { linenums: [{\n            type: Input\n        }], content: [{\n            type: ViewChild,\n            args: ['content']\n        }], codeComponents: [{\n            type: ViewChildren,\n            args: [CodeComponent]\n        }] });\n","/* tslint:disable component-selector */\nimport { Component, AfterViewInit, ViewChild, Input, ViewChildren, QueryList, OnInit } from '@angular/core';\nimport { CodeComponent } from './code.component';\n\nexport interface TabInfo {\n  class: string|null;\n  code: string;\n  language: string|null;\n  linenums: any;\n  path: string;\n  region: string;\n  header: string|null;\n}\n\n/**\n * Renders a set of tab group of code snippets.\n *\n * The innerHTML of the `<code-tabs>` component should contain `<code-pane>` elements.\n * Each `<code-pane>` has the same interface as the embedded `<code-example>` component.\n * The optional `linenums` attribute is the default `linenums` for each code pane.\n */\n@Component({\n  selector: 'code-tabs',\n  template: `\n    <!-- Use content projection so that the provided HTML's code-panes can be split into tabs -->\n    <div #content style=\"display: none\"><ng-content></ng-content></div>\n\n    <mat-card>\n      <mat-tab-group class=\"code-tab-group\" disableRipple>\n        <mat-tab style=\"overflow-y: hidden;\" *ngFor=\"let tab of tabs\">\n          <ng-template mat-tab-label>\n            <span class=\"{{ tab.class }}\">{{ tab.header }}</span>\n          </ng-template>\n          <aio-code class=\"{{ tab.class }}\"\n                    [language]=\"tab.language\"\n                    [linenums]=\"tab.linenums\"\n                    [path]=\"tab.path\"\n                    [region]=\"tab.region\"\n                    [header]=\"tab.header\">\n          </aio-code>\n        </mat-tab>\n      </mat-tab-group>\n    </mat-card>\n  `,\n})\nexport class CodeTabsComponent implements OnInit, AfterViewInit {\n  tabs: TabInfo[];\n\n  @Input() linenums: string;\n\n  @ViewChild('content') content;\n\n  @ViewChildren(CodeComponent) codeComponents: QueryList<CodeComponent>;\n\n  ngOnInit() {\n    this.tabs = [];\n    const codeExamples = this.content.nativeElement.querySelectorAll('code-pane');\n\n    for (let i = 0; i < codeExamples.length; i++) {\n      const tabContent = codeExamples[i];\n      this.tabs.push(this.getTabInfo(tabContent));\n    }\n  }\n\n  ngAfterViewInit() {\n    this.codeComponents.toArray().forEach((codeComponent, i) => {\n      codeComponent.code = this.tabs[i].code;\n    });\n  }\n\n  /** Gets the extracted TabInfo data from the provided code-pane element. */\n  private getTabInfo(tabContent: HTMLElement): TabInfo {\n    return {\n      class: tabContent.getAttribute('class'),\n      code: tabContent.innerHTML,\n      language: tabContent.getAttribute('language'),\n      linenums: tabContent.getAttribute('linenums') || this.linenums,\n      path: tabContent.getAttribute('path') || '',\n      region: tabContent.getAttribute('region') || '',\n      header: tabContent.getAttribute('header')\n    };\n  }\n}\n","import { NgModule, Type } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CodeTabsComponent } from './code-tabs.component';\nimport { MatCardModule, MatTabsModule } from '@angular/material';\nimport { CodeModule } from './code.module';\nimport { WithCustomElementComponent } from '../element-registry';\n\n@NgModule({\n  imports: [ CommonModule, MatCardModule, MatTabsModule, CodeModule ],\n  declarations: [ CodeTabsComponent ],\n  exports: [ CodeTabsComponent ],\n  entryComponents: [ CodeTabsComponent ]\n})\nexport class CodeTabsModule implements WithCustomElementComponent {\n  customElementComponent: Type<any> = CodeTabsComponent;\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CodeTabsComponent } from './code-tabs.component';\nimport { MatCardModule, MatTabsModule } from '@angular/material';\nimport { CodeModule } from './code.module';\nimport * as i0 from \"@angular/core\";\nvar CodeTabsModule = /** @class */ (function () {\n    function CodeTabsModule() {\n        this.customElementComponent = CodeTabsComponent;\n    }\n    CodeTabsModule.ngModuleDef = i0.ɵdefineNgModule({ type: CodeTabsModule });\n    CodeTabsModule.ngInjectorDef = i0.defineInjector({ factory: function CodeTabsModule_Factory(t) { return new (t || CodeTabsModule)(); }, imports: [[CommonModule, MatCardModule, MatTabsModule, CodeModule]] });\n    return CodeTabsModule;\n}());\nexport { CodeTabsModule };\n/*@__PURE__*/ i0.ɵsetNgModuleScope(CodeTabsModule, { declarations: [CodeTabsComponent], imports: [CommonModule, MatCardModule, MatTabsModule, CodeModule], exports: [CodeTabsComponent] });\n/*@__PURE__*/ i0.ɵsetClassMetadata(CodeTabsModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule, MatCardModule, MatTabsModule, CodeModule],\n                declarations: [CodeTabsComponent],\n                exports: [CodeTabsComponent],\n                entryComponents: [CodeTabsComponent]\n            }]\n    }], null, null);\n","import * as i0 from '@angular/core';\nimport {CodeTabsModule} from './code-tabs.module';\nexport const CodeTabsModuleNgFactory = new i0.ɵNgModuleFactory(CodeTabsModule);\nexport const ɵNonEmptyModule = true;"],"sourceRoot":""}